// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/company"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/educationcategory"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/emailverification"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/grade"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/inquiry"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonconfirmation"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonplan"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonreservation"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonreservationpreferreddate"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonschedule"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/predicate"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/product"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/school"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/subject"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/uploadfile"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCompany                        = "Company"
	TypeEducationCategory              = "EducationCategory"
	TypeEmailVerification              = "EmailVerification"
	TypeGrade                          = "Grade"
	TypeInquiry                        = "Inquiry"
	TypeLessonConfirmation             = "LessonConfirmation"
	TypeLessonPlan                     = "LessonPlan"
	TypeLessonReservation              = "LessonReservation"
	TypeLessonReservationPreferredDate = "LessonReservationPreferredDate"
	TypeLessonSchedule                 = "LessonSchedule"
	TypeProduct                        = "Product"
	TypeSchool                         = "School"
	TypeSubject                        = "Subject"
	TypeUploadFile                     = "UploadFile"
	TypeUser                           = "User"
)

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	prefecture          *int
	addprefecture       *int
	city                *string
	street              *string
	post_code           *string
	phone_number        *string
	url                 *string
	clearedFields       map[string]struct{}
	lesson_plans        map[int]struct{}
	removedlesson_plans map[int]struct{}
	clearedlesson_plans bool
	members             map[int]struct{}
	removedmembers      map[int]struct{}
	clearedmembers      bool
	done                bool
	oldValue            func(context.Context) (*Company, error)
	predicates          []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id int) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Company.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CompanyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompanyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompanyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CompanyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CompanyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CompanyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetPrefecture sets the "prefecture" field.
func (m *CompanyMutation) SetPrefecture(i int) {
	m.prefecture = &i
	m.addprefecture = nil
}

// Prefecture returns the value of the "prefecture" field in the mutation.
func (m *CompanyMutation) Prefecture() (r int, exists bool) {
	v := m.prefecture
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefecture returns the old "prefecture" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldPrefecture(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefecture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefecture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefecture: %w", err)
	}
	return oldValue.Prefecture, nil
}

// AddPrefecture adds i to the "prefecture" field.
func (m *CompanyMutation) AddPrefecture(i int) {
	if m.addprefecture != nil {
		*m.addprefecture += i
	} else {
		m.addprefecture = &i
	}
}

// AddedPrefecture returns the value that was added to the "prefecture" field in this mutation.
func (m *CompanyMutation) AddedPrefecture() (r int, exists bool) {
	v := m.addprefecture
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrefecture resets all changes to the "prefecture" field.
func (m *CompanyMutation) ResetPrefecture() {
	m.prefecture = nil
	m.addprefecture = nil
}

// SetCity sets the "city" field.
func (m *CompanyMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CompanyMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *CompanyMutation) ResetCity() {
	m.city = nil
}

// SetStreet sets the "street" field.
func (m *CompanyMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the value of the "street" field in the mutation.
func (m *CompanyMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "street" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "street" field.
func (m *CompanyMutation) ClearStreet() {
	m.street = nil
	m.clearedFields[company.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "street" field was cleared in this mutation.
func (m *CompanyMutation) StreetCleared() bool {
	_, ok := m.clearedFields[company.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "street" field.
func (m *CompanyMutation) ResetStreet() {
	m.street = nil
	delete(m.clearedFields, company.FieldStreet)
}

// SetPostCode sets the "post_code" field.
func (m *CompanyMutation) SetPostCode(s string) {
	m.post_code = &s
}

// PostCode returns the value of the "post_code" field in the mutation.
func (m *CompanyMutation) PostCode() (r string, exists bool) {
	v := m.post_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCode returns the old "post_code" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldPostCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCode: %w", err)
	}
	return oldValue.PostCode, nil
}

// ResetPostCode resets all changes to the "post_code" field.
func (m *CompanyMutation) ResetPostCode() {
	m.post_code = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *CompanyMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *CompanyMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *CompanyMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetURL sets the "url" field.
func (m *CompanyMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CompanyMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *CompanyMutation) ClearURL() {
	m.url = nil
	m.clearedFields[company.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *CompanyMutation) URLCleared() bool {
	_, ok := m.clearedFields[company.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *CompanyMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, company.FieldURL)
}

// AddLessonPlanIDs adds the "lesson_plans" edge to the LessonPlan entity by ids.
func (m *CompanyMutation) AddLessonPlanIDs(ids ...int) {
	if m.lesson_plans == nil {
		m.lesson_plans = make(map[int]struct{})
	}
	for i := range ids {
		m.lesson_plans[ids[i]] = struct{}{}
	}
}

// ClearLessonPlans clears the "lesson_plans" edge to the LessonPlan entity.
func (m *CompanyMutation) ClearLessonPlans() {
	m.clearedlesson_plans = true
}

// LessonPlansCleared reports if the "lesson_plans" edge to the LessonPlan entity was cleared.
func (m *CompanyMutation) LessonPlansCleared() bool {
	return m.clearedlesson_plans
}

// RemoveLessonPlanIDs removes the "lesson_plans" edge to the LessonPlan entity by IDs.
func (m *CompanyMutation) RemoveLessonPlanIDs(ids ...int) {
	if m.removedlesson_plans == nil {
		m.removedlesson_plans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lesson_plans, ids[i])
		m.removedlesson_plans[ids[i]] = struct{}{}
	}
}

// RemovedLessonPlans returns the removed IDs of the "lesson_plans" edge to the LessonPlan entity.
func (m *CompanyMutation) RemovedLessonPlansIDs() (ids []int) {
	for id := range m.removedlesson_plans {
		ids = append(ids, id)
	}
	return
}

// LessonPlansIDs returns the "lesson_plans" edge IDs in the mutation.
func (m *CompanyMutation) LessonPlansIDs() (ids []int) {
	for id := range m.lesson_plans {
		ids = append(ids, id)
	}
	return
}

// ResetLessonPlans resets all changes to the "lesson_plans" edge.
func (m *CompanyMutation) ResetLessonPlans() {
	m.lesson_plans = nil
	m.clearedlesson_plans = false
	m.removedlesson_plans = nil
}

// AddMemberIDs adds the "members" edge to the User entity by ids.
func (m *CompanyMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the User entity.
func (m *CompanyMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the User entity was cleared.
func (m *CompanyMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the User entity by IDs.
func (m *CompanyMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the User entity.
func (m *CompanyMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *CompanyMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *CompanyMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Company, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, company.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, company.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.prefecture != nil {
		fields = append(fields, company.FieldPrefecture)
	}
	if m.city != nil {
		fields = append(fields, company.FieldCity)
	}
	if m.street != nil {
		fields = append(fields, company.FieldStreet)
	}
	if m.post_code != nil {
		fields = append(fields, company.FieldPostCode)
	}
	if m.phone_number != nil {
		fields = append(fields, company.FieldPhoneNumber)
	}
	if m.url != nil {
		fields = append(fields, company.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldCreatedAt:
		return m.CreatedAt()
	case company.FieldUpdatedAt:
		return m.UpdatedAt()
	case company.FieldName:
		return m.Name()
	case company.FieldPrefecture:
		return m.Prefecture()
	case company.FieldCity:
		return m.City()
	case company.FieldStreet:
		return m.Street()
	case company.FieldPostCode:
		return m.PostCode()
	case company.FieldPhoneNumber:
		return m.PhoneNumber()
	case company.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case company.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldPrefecture:
		return m.OldPrefecture(ctx)
	case company.FieldCity:
		return m.OldCity(ctx)
	case company.FieldStreet:
		return m.OldStreet(ctx)
	case company.FieldPostCode:
		return m.OldPostCode(ctx)
	case company.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case company.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case company.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldPrefecture:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefecture(v)
		return nil
	case company.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case company.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case company.FieldPostCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCode(v)
		return nil
	case company.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case company.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	var fields []string
	if m.addprefecture != nil {
		fields = append(fields, company.FieldPrefecture)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case company.FieldPrefecture:
		return m.AddedPrefecture()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case company.FieldPrefecture:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrefecture(v)
		return nil
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(company.FieldStreet) {
		fields = append(fields, company.FieldStreet)
	}
	if m.FieldCleared(company.FieldURL) {
		fields = append(fields, company.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	switch name {
	case company.FieldStreet:
		m.ClearStreet()
		return nil
	case company.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case company.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldPrefecture:
		m.ResetPrefecture()
		return nil
	case company.FieldCity:
		m.ResetCity()
		return nil
	case company.FieldStreet:
		m.ResetStreet()
		return nil
	case company.FieldPostCode:
		m.ResetPostCode()
		return nil
	case company.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case company.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lesson_plans != nil {
		edges = append(edges, company.EdgeLessonPlans)
	}
	if m.members != nil {
		edges = append(edges, company.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeLessonPlans:
		ids := make([]ent.Value, 0, len(m.lesson_plans))
		for id := range m.lesson_plans {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlesson_plans != nil {
		edges = append(edges, company.EdgeLessonPlans)
	}
	if m.removedmembers != nil {
		edges = append(edges, company.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeLessonPlans:
		ids := make([]ent.Value, 0, len(m.removedlesson_plans))
		for id := range m.removedlesson_plans {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlesson_plans {
		edges = append(edges, company.EdgeLessonPlans)
	}
	if m.clearedmembers {
		edges = append(edges, company.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeLessonPlans:
		return m.clearedlesson_plans
	case company.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeLessonPlans:
		m.ResetLessonPlans()
		return nil
	case company.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// EducationCategoryMutation represents an operation that mutates the EducationCategory nodes in the graph.
type EducationCategoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	code                *string
	clearedFields       map[string]struct{}
	lesson_plans        map[int]struct{}
	removedlesson_plans map[int]struct{}
	clearedlesson_plans bool
	done                bool
	oldValue            func(context.Context) (*EducationCategory, error)
	predicates          []predicate.EducationCategory
}

var _ ent.Mutation = (*EducationCategoryMutation)(nil)

// educationcategoryOption allows management of the mutation configuration using functional options.
type educationcategoryOption func(*EducationCategoryMutation)

// newEducationCategoryMutation creates new mutation for the EducationCategory entity.
func newEducationCategoryMutation(c config, op Op, opts ...educationcategoryOption) *EducationCategoryMutation {
	m := &EducationCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEducationCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationCategoryID sets the ID field of the mutation.
func withEducationCategoryID(id int) educationcategoryOption {
	return func(m *EducationCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EducationCategory
		)
		m.oldValue = func(ctx context.Context) (*EducationCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EducationCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducationCategory sets the old EducationCategory of the mutation.
func withEducationCategory(node *EducationCategory) educationcategoryOption {
	return func(m *EducationCategoryMutation) {
		m.oldValue = func(context.Context) (*EducationCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EducationCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EducationCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EducationCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EducationCategory entity.
// If the EducationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EducationCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EducationCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EducationCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EducationCategory entity.
// If the EducationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EducationCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *EducationCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EducationCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EducationCategory entity.
// If the EducationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EducationCategoryMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *EducationCategoryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *EducationCategoryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the EducationCategory entity.
// If the EducationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationCategoryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *EducationCategoryMutation) ResetCode() {
	m.code = nil
}

// AddLessonPlanIDs adds the "lesson_plans" edge to the LessonPlan entity by ids.
func (m *EducationCategoryMutation) AddLessonPlanIDs(ids ...int) {
	if m.lesson_plans == nil {
		m.lesson_plans = make(map[int]struct{})
	}
	for i := range ids {
		m.lesson_plans[ids[i]] = struct{}{}
	}
}

// ClearLessonPlans clears the "lesson_plans" edge to the LessonPlan entity.
func (m *EducationCategoryMutation) ClearLessonPlans() {
	m.clearedlesson_plans = true
}

// LessonPlansCleared reports if the "lesson_plans" edge to the LessonPlan entity was cleared.
func (m *EducationCategoryMutation) LessonPlansCleared() bool {
	return m.clearedlesson_plans
}

// RemoveLessonPlanIDs removes the "lesson_plans" edge to the LessonPlan entity by IDs.
func (m *EducationCategoryMutation) RemoveLessonPlanIDs(ids ...int) {
	if m.removedlesson_plans == nil {
		m.removedlesson_plans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lesson_plans, ids[i])
		m.removedlesson_plans[ids[i]] = struct{}{}
	}
}

// RemovedLessonPlans returns the removed IDs of the "lesson_plans" edge to the LessonPlan entity.
func (m *EducationCategoryMutation) RemovedLessonPlansIDs() (ids []int) {
	for id := range m.removedlesson_plans {
		ids = append(ids, id)
	}
	return
}

// LessonPlansIDs returns the "lesson_plans" edge IDs in the mutation.
func (m *EducationCategoryMutation) LessonPlansIDs() (ids []int) {
	for id := range m.lesson_plans {
		ids = append(ids, id)
	}
	return
}

// ResetLessonPlans resets all changes to the "lesson_plans" edge.
func (m *EducationCategoryMutation) ResetLessonPlans() {
	m.lesson_plans = nil
	m.clearedlesson_plans = false
	m.removedlesson_plans = nil
}

// Where appends a list predicates to the EducationCategoryMutation builder.
func (m *EducationCategoryMutation) Where(ps ...predicate.EducationCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EducationCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EducationCategory).
func (m *EducationCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, educationcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, educationcategory.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, educationcategory.FieldName)
	}
	if m.code != nil {
		fields = append(fields, educationcategory.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case educationcategory.FieldCreatedAt:
		return m.CreatedAt()
	case educationcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case educationcategory.FieldName:
		return m.Name()
	case educationcategory.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case educationcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case educationcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case educationcategory.FieldName:
		return m.OldName(ctx)
	case educationcategory.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown EducationCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case educationcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case educationcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case educationcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case educationcategory.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown EducationCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EducationCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EducationCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationCategoryMutation) ResetField(name string) error {
	switch name {
	case educationcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case educationcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case educationcategory.FieldName:
		m.ResetName()
		return nil
	case educationcategory.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown EducationCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lesson_plans != nil {
		edges = append(edges, educationcategory.EdgeLessonPlans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case educationcategory.EdgeLessonPlans:
		ids := make([]ent.Value, 0, len(m.lesson_plans))
		for id := range m.lesson_plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlesson_plans != nil {
		edges = append(edges, educationcategory.EdgeLessonPlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case educationcategory.EdgeLessonPlans:
		ids := make([]ent.Value, 0, len(m.removedlesson_plans))
		for id := range m.removedlesson_plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlesson_plans {
		edges = append(edges, educationcategory.EdgeLessonPlans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case educationcategory.EdgeLessonPlans:
		return m.clearedlesson_plans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EducationCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationCategoryMutation) ResetEdge(name string) error {
	switch name {
	case educationcategory.EdgeLessonPlans:
		m.ResetLessonPlans()
		return nil
	}
	return fmt.Errorf("unknown EducationCategory edge %s", name)
}

// EmailVerificationMutation represents an operation that mutates the EmailVerification nodes in the graph.
type EmailVerificationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	email         *string
	token         *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EmailVerification, error)
	predicates    []predicate.EmailVerification
}

var _ ent.Mutation = (*EmailVerificationMutation)(nil)

// emailverificationOption allows management of the mutation configuration using functional options.
type emailverificationOption func(*EmailVerificationMutation)

// newEmailVerificationMutation creates new mutation for the EmailVerification entity.
func newEmailVerificationMutation(c config, op Op, opts ...emailverificationOption) *EmailVerificationMutation {
	m := &EmailVerificationMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailVerification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailVerificationID sets the ID field of the mutation.
func withEmailVerificationID(id int) emailverificationOption {
	return func(m *EmailVerificationMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailVerification
		)
		m.oldValue = func(ctx context.Context) (*EmailVerification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailVerification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailVerification sets the old EmailVerification of the mutation.
func withEmailVerification(node *EmailVerification) emailverificationOption {
	return func(m *EmailVerificationMutation) {
		m.oldValue = func(context.Context) (*EmailVerification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailVerificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailVerificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailVerificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailVerificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailVerification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailVerificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailVerificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailVerification entity.
// If the EmailVerification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailVerificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailVerificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailVerificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailVerification entity.
// If the EmailVerification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailVerificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *EmailVerificationMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmailVerificationMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the EmailVerification entity.
// If the EmailVerification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmailVerificationMutation) ResetEmail() {
	m.email = nil
}

// SetToken sets the "token" field.
func (m *EmailVerificationMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *EmailVerificationMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the EmailVerification entity.
// If the EmailVerification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *EmailVerificationMutation) ResetToken() {
	m.token = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *EmailVerificationMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *EmailVerificationMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the EmailVerification entity.
// If the EmailVerification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *EmailVerificationMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// Where appends a list predicates to the EmailVerificationMutation builder.
func (m *EmailVerificationMutation) Where(ps ...predicate.EmailVerification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailVerificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailVerificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailVerification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailVerificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailVerificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailVerification).
func (m *EmailVerificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailVerificationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, emailverification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailverification.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, emailverification.FieldEmail)
	}
	if m.token != nil {
		fields = append(fields, emailverification.FieldToken)
	}
	if m.expired_at != nil {
		fields = append(fields, emailverification.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailVerificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailverification.FieldCreatedAt:
		return m.CreatedAt()
	case emailverification.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailverification.FieldEmail:
		return m.Email()
	case emailverification.FieldToken:
		return m.Token()
	case emailverification.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailVerificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailverification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailverification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailverification.FieldEmail:
		return m.OldEmail(ctx)
	case emailverification.FieldToken:
		return m.OldToken(ctx)
	case emailverification.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailVerification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailVerificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailverification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailverification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailverification.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case emailverification.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case emailverification.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailVerification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailVerificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailVerificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailVerificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailVerification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailVerificationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailVerificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailVerificationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmailVerification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailVerificationMutation) ResetField(name string) error {
	switch name {
	case emailverification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailverification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailverification.FieldEmail:
		m.ResetEmail()
		return nil
	case emailverification.FieldToken:
		m.ResetToken()
		return nil
	case emailverification.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown EmailVerification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailVerificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailVerificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailVerificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailVerificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailVerificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailVerificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailVerificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmailVerification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailVerificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmailVerification edge %s", name)
}

// GradeMutation represents an operation that mutates the Grade nodes in the graph.
type GradeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	code                *string
	clearedFields       map[string]struct{}
	lesson_plans        map[int]struct{}
	removedlesson_plans map[int]struct{}
	clearedlesson_plans bool
	done                bool
	oldValue            func(context.Context) (*Grade, error)
	predicates          []predicate.Grade
}

var _ ent.Mutation = (*GradeMutation)(nil)

// gradeOption allows management of the mutation configuration using functional options.
type gradeOption func(*GradeMutation)

// newGradeMutation creates new mutation for the Grade entity.
func newGradeMutation(c config, op Op, opts ...gradeOption) *GradeMutation {
	m := &GradeMutation{
		config:        c,
		op:            op,
		typ:           TypeGrade,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGradeID sets the ID field of the mutation.
func withGradeID(id int) gradeOption {
	return func(m *GradeMutation) {
		var (
			err   error
			once  sync.Once
			value *Grade
		)
		m.oldValue = func(ctx context.Context) (*Grade, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grade.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrade sets the old Grade of the mutation.
func withGrade(node *Grade) gradeOption {
	return func(m *GradeMutation) {
		m.oldValue = func(context.Context) (*Grade, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GradeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GradeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GradeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GradeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grade.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GradeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GradeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Grade entity.
// If the Grade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GradeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GradeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GradeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GradeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Grade entity.
// If the Grade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GradeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GradeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *GradeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GradeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Grade entity.
// If the Grade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GradeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GradeMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *GradeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *GradeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Grade entity.
// If the Grade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GradeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *GradeMutation) ResetCode() {
	m.code = nil
}

// AddLessonPlanIDs adds the "lesson_plans" edge to the LessonPlan entity by ids.
func (m *GradeMutation) AddLessonPlanIDs(ids ...int) {
	if m.lesson_plans == nil {
		m.lesson_plans = make(map[int]struct{})
	}
	for i := range ids {
		m.lesson_plans[ids[i]] = struct{}{}
	}
}

// ClearLessonPlans clears the "lesson_plans" edge to the LessonPlan entity.
func (m *GradeMutation) ClearLessonPlans() {
	m.clearedlesson_plans = true
}

// LessonPlansCleared reports if the "lesson_plans" edge to the LessonPlan entity was cleared.
func (m *GradeMutation) LessonPlansCleared() bool {
	return m.clearedlesson_plans
}

// RemoveLessonPlanIDs removes the "lesson_plans" edge to the LessonPlan entity by IDs.
func (m *GradeMutation) RemoveLessonPlanIDs(ids ...int) {
	if m.removedlesson_plans == nil {
		m.removedlesson_plans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lesson_plans, ids[i])
		m.removedlesson_plans[ids[i]] = struct{}{}
	}
}

// RemovedLessonPlans returns the removed IDs of the "lesson_plans" edge to the LessonPlan entity.
func (m *GradeMutation) RemovedLessonPlansIDs() (ids []int) {
	for id := range m.removedlesson_plans {
		ids = append(ids, id)
	}
	return
}

// LessonPlansIDs returns the "lesson_plans" edge IDs in the mutation.
func (m *GradeMutation) LessonPlansIDs() (ids []int) {
	for id := range m.lesson_plans {
		ids = append(ids, id)
	}
	return
}

// ResetLessonPlans resets all changes to the "lesson_plans" edge.
func (m *GradeMutation) ResetLessonPlans() {
	m.lesson_plans = nil
	m.clearedlesson_plans = false
	m.removedlesson_plans = nil
}

// Where appends a list predicates to the GradeMutation builder.
func (m *GradeMutation) Where(ps ...predicate.Grade) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GradeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GradeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Grade, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GradeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GradeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Grade).
func (m *GradeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GradeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, grade.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, grade.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, grade.FieldName)
	}
	if m.code != nil {
		fields = append(fields, grade.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GradeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grade.FieldCreatedAt:
		return m.CreatedAt()
	case grade.FieldUpdatedAt:
		return m.UpdatedAt()
	case grade.FieldName:
		return m.Name()
	case grade.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GradeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grade.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case grade.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case grade.FieldName:
		return m.OldName(ctx)
	case grade.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Grade field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GradeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grade.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grade.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case grade.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case grade.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Grade field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GradeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GradeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GradeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Grade numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GradeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GradeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GradeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Grade nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GradeMutation) ResetField(name string) error {
	switch name {
	case grade.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grade.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case grade.FieldName:
		m.ResetName()
		return nil
	case grade.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Grade field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GradeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lesson_plans != nil {
		edges = append(edges, grade.EdgeLessonPlans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GradeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grade.EdgeLessonPlans:
		ids := make([]ent.Value, 0, len(m.lesson_plans))
		for id := range m.lesson_plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GradeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlesson_plans != nil {
		edges = append(edges, grade.EdgeLessonPlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GradeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case grade.EdgeLessonPlans:
		ids := make([]ent.Value, 0, len(m.removedlesson_plans))
		for id := range m.removedlesson_plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GradeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlesson_plans {
		edges = append(edges, grade.EdgeLessonPlans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GradeMutation) EdgeCleared(name string) bool {
	switch name {
	case grade.EdgeLessonPlans:
		return m.clearedlesson_plans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GradeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Grade unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GradeMutation) ResetEdge(name string) error {
	switch name {
	case grade.EdgeLessonPlans:
		m.ResetLessonPlans()
		return nil
	}
	return fmt.Errorf("unknown Grade edge %s", name)
}

// InquiryMutation represents an operation that mutates the Inquiry nodes in the graph.
type InquiryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	category       *inquiry.Category
	inquiry_detail *string
	clearedFields  map[string]struct{}
	lesson         *int
	clearedlesson  bool
	school         *int
	clearedschool  bool
	teacher        *int
	clearedteacher bool
	done           bool
	oldValue       func(context.Context) (*Inquiry, error)
	predicates     []predicate.Inquiry
}

var _ ent.Mutation = (*InquiryMutation)(nil)

// inquiryOption allows management of the mutation configuration using functional options.
type inquiryOption func(*InquiryMutation)

// newInquiryMutation creates new mutation for the Inquiry entity.
func newInquiryMutation(c config, op Op, opts ...inquiryOption) *InquiryMutation {
	m := &InquiryMutation{
		config:        c,
		op:            op,
		typ:           TypeInquiry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInquiryID sets the ID field of the mutation.
func withInquiryID(id int) inquiryOption {
	return func(m *InquiryMutation) {
		var (
			err   error
			once  sync.Once
			value *Inquiry
		)
		m.oldValue = func(ctx context.Context) (*Inquiry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inquiry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInquiry sets the old Inquiry of the mutation.
func withInquiry(node *Inquiry) inquiryOption {
	return func(m *InquiryMutation) {
		m.oldValue = func(context.Context) (*Inquiry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InquiryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InquiryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InquiryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InquiryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inquiry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InquiryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InquiryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Inquiry entity.
// If the Inquiry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InquiryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InquiryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InquiryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InquiryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Inquiry entity.
// If the Inquiry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InquiryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InquiryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLessonScheduleID sets the "lesson_schedule_id" field.
func (m *InquiryMutation) SetLessonScheduleID(i int) {
	m.lesson = &i
}

// LessonScheduleID returns the value of the "lesson_schedule_id" field in the mutation.
func (m *InquiryMutation) LessonScheduleID() (r int, exists bool) {
	v := m.lesson
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonScheduleID returns the old "lesson_schedule_id" field's value of the Inquiry entity.
// If the Inquiry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InquiryMutation) OldLessonScheduleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonScheduleID: %w", err)
	}
	return oldValue.LessonScheduleID, nil
}

// ResetLessonScheduleID resets all changes to the "lesson_schedule_id" field.
func (m *InquiryMutation) ResetLessonScheduleID() {
	m.lesson = nil
}

// SetSchoolID sets the "school_id" field.
func (m *InquiryMutation) SetSchoolID(i int) {
	m.school = &i
}

// SchoolID returns the value of the "school_id" field in the mutation.
func (m *InquiryMutation) SchoolID() (r int, exists bool) {
	v := m.school
	if v == nil {
		return
	}
	return *v, true
}

// OldSchoolID returns the old "school_id" field's value of the Inquiry entity.
// If the Inquiry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InquiryMutation) OldSchoolID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchoolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchoolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchoolID: %w", err)
	}
	return oldValue.SchoolID, nil
}

// ResetSchoolID resets all changes to the "school_id" field.
func (m *InquiryMutation) ResetSchoolID() {
	m.school = nil
}

// SetUserID sets the "user_id" field.
func (m *InquiryMutation) SetUserID(i int) {
	m.teacher = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InquiryMutation) UserID() (r int, exists bool) {
	v := m.teacher
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Inquiry entity.
// If the Inquiry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InquiryMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InquiryMutation) ResetUserID() {
	m.teacher = nil
}

// SetCategory sets the "category" field.
func (m *InquiryMutation) SetCategory(i inquiry.Category) {
	m.category = &i
}

// Category returns the value of the "category" field in the mutation.
func (m *InquiryMutation) Category() (r inquiry.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Inquiry entity.
// If the Inquiry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InquiryMutation) OldCategory(ctx context.Context) (v inquiry.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *InquiryMutation) ResetCategory() {
	m.category = nil
}

// SetInquiryDetail sets the "inquiry_detail" field.
func (m *InquiryMutation) SetInquiryDetail(s string) {
	m.inquiry_detail = &s
}

// InquiryDetail returns the value of the "inquiry_detail" field in the mutation.
func (m *InquiryMutation) InquiryDetail() (r string, exists bool) {
	v := m.inquiry_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldInquiryDetail returns the old "inquiry_detail" field's value of the Inquiry entity.
// If the Inquiry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InquiryMutation) OldInquiryDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInquiryDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInquiryDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInquiryDetail: %w", err)
	}
	return oldValue.InquiryDetail, nil
}

// ResetInquiryDetail resets all changes to the "inquiry_detail" field.
func (m *InquiryMutation) ResetInquiryDetail() {
	m.inquiry_detail = nil
}

// SetLessonID sets the "lesson" edge to the LessonPlan entity by id.
func (m *InquiryMutation) SetLessonID(id int) {
	m.lesson = &id
}

// ClearLesson clears the "lesson" edge to the LessonPlan entity.
func (m *InquiryMutation) ClearLesson() {
	m.clearedlesson = true
	m.clearedFields[inquiry.FieldLessonScheduleID] = struct{}{}
}

// LessonCleared reports if the "lesson" edge to the LessonPlan entity was cleared.
func (m *InquiryMutation) LessonCleared() bool {
	return m.clearedlesson
}

// LessonID returns the "lesson" edge ID in the mutation.
func (m *InquiryMutation) LessonID() (id int, exists bool) {
	if m.lesson != nil {
		return *m.lesson, true
	}
	return
}

// LessonIDs returns the "lesson" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LessonID instead. It exists only for internal usage by the builders.
func (m *InquiryMutation) LessonIDs() (ids []int) {
	if id := m.lesson; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLesson resets all changes to the "lesson" edge.
func (m *InquiryMutation) ResetLesson() {
	m.lesson = nil
	m.clearedlesson = false
}

// ClearSchool clears the "school" edge to the School entity.
func (m *InquiryMutation) ClearSchool() {
	m.clearedschool = true
	m.clearedFields[inquiry.FieldSchoolID] = struct{}{}
}

// SchoolCleared reports if the "school" edge to the School entity was cleared.
func (m *InquiryMutation) SchoolCleared() bool {
	return m.clearedschool
}

// SchoolIDs returns the "school" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchoolID instead. It exists only for internal usage by the builders.
func (m *InquiryMutation) SchoolIDs() (ids []int) {
	if id := m.school; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchool resets all changes to the "school" edge.
func (m *InquiryMutation) ResetSchool() {
	m.school = nil
	m.clearedschool = false
}

// SetTeacherID sets the "teacher" edge to the User entity by id.
func (m *InquiryMutation) SetTeacherID(id int) {
	m.teacher = &id
}

// ClearTeacher clears the "teacher" edge to the User entity.
func (m *InquiryMutation) ClearTeacher() {
	m.clearedteacher = true
	m.clearedFields[inquiry.FieldUserID] = struct{}{}
}

// TeacherCleared reports if the "teacher" edge to the User entity was cleared.
func (m *InquiryMutation) TeacherCleared() bool {
	return m.clearedteacher
}

// TeacherID returns the "teacher" edge ID in the mutation.
func (m *InquiryMutation) TeacherID() (id int, exists bool) {
	if m.teacher != nil {
		return *m.teacher, true
	}
	return
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *InquiryMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *InquiryMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// Where appends a list predicates to the InquiryMutation builder.
func (m *InquiryMutation) Where(ps ...predicate.Inquiry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InquiryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InquiryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Inquiry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InquiryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InquiryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Inquiry).
func (m *InquiryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InquiryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, inquiry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inquiry.FieldUpdatedAt)
	}
	if m.lesson != nil {
		fields = append(fields, inquiry.FieldLessonScheduleID)
	}
	if m.school != nil {
		fields = append(fields, inquiry.FieldSchoolID)
	}
	if m.teacher != nil {
		fields = append(fields, inquiry.FieldUserID)
	}
	if m.category != nil {
		fields = append(fields, inquiry.FieldCategory)
	}
	if m.inquiry_detail != nil {
		fields = append(fields, inquiry.FieldInquiryDetail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InquiryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inquiry.FieldCreatedAt:
		return m.CreatedAt()
	case inquiry.FieldUpdatedAt:
		return m.UpdatedAt()
	case inquiry.FieldLessonScheduleID:
		return m.LessonScheduleID()
	case inquiry.FieldSchoolID:
		return m.SchoolID()
	case inquiry.FieldUserID:
		return m.UserID()
	case inquiry.FieldCategory:
		return m.Category()
	case inquiry.FieldInquiryDetail:
		return m.InquiryDetail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InquiryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inquiry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inquiry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inquiry.FieldLessonScheduleID:
		return m.OldLessonScheduleID(ctx)
	case inquiry.FieldSchoolID:
		return m.OldSchoolID(ctx)
	case inquiry.FieldUserID:
		return m.OldUserID(ctx)
	case inquiry.FieldCategory:
		return m.OldCategory(ctx)
	case inquiry.FieldInquiryDetail:
		return m.OldInquiryDetail(ctx)
	}
	return nil, fmt.Errorf("unknown Inquiry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InquiryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inquiry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inquiry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inquiry.FieldLessonScheduleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonScheduleID(v)
		return nil
	case inquiry.FieldSchoolID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchoolID(v)
		return nil
	case inquiry.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case inquiry.FieldCategory:
		v, ok := value.(inquiry.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case inquiry.FieldInquiryDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInquiryDetail(v)
		return nil
	}
	return fmt.Errorf("unknown Inquiry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InquiryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InquiryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InquiryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Inquiry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InquiryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InquiryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InquiryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Inquiry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InquiryMutation) ResetField(name string) error {
	switch name {
	case inquiry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inquiry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inquiry.FieldLessonScheduleID:
		m.ResetLessonScheduleID()
		return nil
	case inquiry.FieldSchoolID:
		m.ResetSchoolID()
		return nil
	case inquiry.FieldUserID:
		m.ResetUserID()
		return nil
	case inquiry.FieldCategory:
		m.ResetCategory()
		return nil
	case inquiry.FieldInquiryDetail:
		m.ResetInquiryDetail()
		return nil
	}
	return fmt.Errorf("unknown Inquiry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InquiryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.lesson != nil {
		edges = append(edges, inquiry.EdgeLesson)
	}
	if m.school != nil {
		edges = append(edges, inquiry.EdgeSchool)
	}
	if m.teacher != nil {
		edges = append(edges, inquiry.EdgeTeacher)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InquiryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inquiry.EdgeLesson:
		if id := m.lesson; id != nil {
			return []ent.Value{*id}
		}
	case inquiry.EdgeSchool:
		if id := m.school; id != nil {
			return []ent.Value{*id}
		}
	case inquiry.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InquiryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InquiryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InquiryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlesson {
		edges = append(edges, inquiry.EdgeLesson)
	}
	if m.clearedschool {
		edges = append(edges, inquiry.EdgeSchool)
	}
	if m.clearedteacher {
		edges = append(edges, inquiry.EdgeTeacher)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InquiryMutation) EdgeCleared(name string) bool {
	switch name {
	case inquiry.EdgeLesson:
		return m.clearedlesson
	case inquiry.EdgeSchool:
		return m.clearedschool
	case inquiry.EdgeTeacher:
		return m.clearedteacher
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InquiryMutation) ClearEdge(name string) error {
	switch name {
	case inquiry.EdgeLesson:
		m.ClearLesson()
		return nil
	case inquiry.EdgeSchool:
		m.ClearSchool()
		return nil
	case inquiry.EdgeTeacher:
		m.ClearTeacher()
		return nil
	}
	return fmt.Errorf("unknown Inquiry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InquiryMutation) ResetEdge(name string) error {
	switch name {
	case inquiry.EdgeLesson:
		m.ResetLesson()
		return nil
	case inquiry.EdgeSchool:
		m.ResetSchool()
		return nil
	case inquiry.EdgeTeacher:
		m.ResetTeacher()
		return nil
	}
	return fmt.Errorf("unknown Inquiry edge %s", name)
}

// LessonConfirmationMutation represents an operation that mutates the LessonConfirmation nodes in the graph.
type LessonConfirmationMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	matching_date             *time.Time
	start_time                *time.Time
	finish_time               *time.Time
	remarks                   *string
	clearedFields             map[string]struct{}
	lesson_reservation        *int
	clearedlesson_reservation bool
	done                      bool
	oldValue                  func(context.Context) (*LessonConfirmation, error)
	predicates                []predicate.LessonConfirmation
}

var _ ent.Mutation = (*LessonConfirmationMutation)(nil)

// lessonconfirmationOption allows management of the mutation configuration using functional options.
type lessonconfirmationOption func(*LessonConfirmationMutation)

// newLessonConfirmationMutation creates new mutation for the LessonConfirmation entity.
func newLessonConfirmationMutation(c config, op Op, opts ...lessonconfirmationOption) *LessonConfirmationMutation {
	m := &LessonConfirmationMutation{
		config:        c,
		op:            op,
		typ:           TypeLessonConfirmation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLessonConfirmationID sets the ID field of the mutation.
func withLessonConfirmationID(id int) lessonconfirmationOption {
	return func(m *LessonConfirmationMutation) {
		var (
			err   error
			once  sync.Once
			value *LessonConfirmation
		)
		m.oldValue = func(ctx context.Context) (*LessonConfirmation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LessonConfirmation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLessonConfirmation sets the old LessonConfirmation of the mutation.
func withLessonConfirmation(node *LessonConfirmation) lessonconfirmationOption {
	return func(m *LessonConfirmationMutation) {
		m.oldValue = func(context.Context) (*LessonConfirmation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonConfirmationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonConfirmationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LessonConfirmationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LessonConfirmationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LessonConfirmation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLessonReservationID sets the "lesson_reservation_id" field.
func (m *LessonConfirmationMutation) SetLessonReservationID(i int) {
	m.lesson_reservation = &i
}

// LessonReservationID returns the value of the "lesson_reservation_id" field in the mutation.
func (m *LessonConfirmationMutation) LessonReservationID() (r int, exists bool) {
	v := m.lesson_reservation
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonReservationID returns the old "lesson_reservation_id" field's value of the LessonConfirmation entity.
// If the LessonConfirmation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonConfirmationMutation) OldLessonReservationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonReservationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonReservationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonReservationID: %w", err)
	}
	return oldValue.LessonReservationID, nil
}

// ResetLessonReservationID resets all changes to the "lesson_reservation_id" field.
func (m *LessonConfirmationMutation) ResetLessonReservationID() {
	m.lesson_reservation = nil
}

// SetMatchingDate sets the "matching_date" field.
func (m *LessonConfirmationMutation) SetMatchingDate(t time.Time) {
	m.matching_date = &t
}

// MatchingDate returns the value of the "matching_date" field in the mutation.
func (m *LessonConfirmationMutation) MatchingDate() (r time.Time, exists bool) {
	v := m.matching_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchingDate returns the old "matching_date" field's value of the LessonConfirmation entity.
// If the LessonConfirmation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonConfirmationMutation) OldMatchingDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchingDate: %w", err)
	}
	return oldValue.MatchingDate, nil
}

// ResetMatchingDate resets all changes to the "matching_date" field.
func (m *LessonConfirmationMutation) ResetMatchingDate() {
	m.matching_date = nil
}

// SetStartTime sets the "start_time" field.
func (m *LessonConfirmationMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *LessonConfirmationMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the LessonConfirmation entity.
// If the LessonConfirmation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonConfirmationMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *LessonConfirmationMutation) ResetStartTime() {
	m.start_time = nil
}

// SetFinishTime sets the "finish_time" field.
func (m *LessonConfirmationMutation) SetFinishTime(t time.Time) {
	m.finish_time = &t
}

// FinishTime returns the value of the "finish_time" field in the mutation.
func (m *LessonConfirmationMutation) FinishTime() (r time.Time, exists bool) {
	v := m.finish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishTime returns the old "finish_time" field's value of the LessonConfirmation entity.
// If the LessonConfirmation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonConfirmationMutation) OldFinishTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishTime: %w", err)
	}
	return oldValue.FinishTime, nil
}

// ResetFinishTime resets all changes to the "finish_time" field.
func (m *LessonConfirmationMutation) ResetFinishTime() {
	m.finish_time = nil
}

// SetRemarks sets the "remarks" field.
func (m *LessonConfirmationMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the value of the "remarks" field in the mutation.
func (m *LessonConfirmationMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old "remarks" field's value of the LessonConfirmation entity.
// If the LessonConfirmation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonConfirmationMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of the "remarks" field.
func (m *LessonConfirmationMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[lessonconfirmation.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the "remarks" field was cleared in this mutation.
func (m *LessonConfirmationMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[lessonconfirmation.FieldRemarks]
	return ok
}

// ResetRemarks resets all changes to the "remarks" field.
func (m *LessonConfirmationMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, lessonconfirmation.FieldRemarks)
}

// ClearLessonReservation clears the "lesson_reservation" edge to the LessonReservation entity.
func (m *LessonConfirmationMutation) ClearLessonReservation() {
	m.clearedlesson_reservation = true
	m.clearedFields[lessonconfirmation.FieldLessonReservationID] = struct{}{}
}

// LessonReservationCleared reports if the "lesson_reservation" edge to the LessonReservation entity was cleared.
func (m *LessonConfirmationMutation) LessonReservationCleared() bool {
	return m.clearedlesson_reservation
}

// LessonReservationIDs returns the "lesson_reservation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LessonReservationID instead. It exists only for internal usage by the builders.
func (m *LessonConfirmationMutation) LessonReservationIDs() (ids []int) {
	if id := m.lesson_reservation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLessonReservation resets all changes to the "lesson_reservation" edge.
func (m *LessonConfirmationMutation) ResetLessonReservation() {
	m.lesson_reservation = nil
	m.clearedlesson_reservation = false
}

// Where appends a list predicates to the LessonConfirmationMutation builder.
func (m *LessonConfirmationMutation) Where(ps ...predicate.LessonConfirmation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonConfirmationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonConfirmationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LessonConfirmation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonConfirmationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonConfirmationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LessonConfirmation).
func (m *LessonConfirmationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonConfirmationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.lesson_reservation != nil {
		fields = append(fields, lessonconfirmation.FieldLessonReservationID)
	}
	if m.matching_date != nil {
		fields = append(fields, lessonconfirmation.FieldMatchingDate)
	}
	if m.start_time != nil {
		fields = append(fields, lessonconfirmation.FieldStartTime)
	}
	if m.finish_time != nil {
		fields = append(fields, lessonconfirmation.FieldFinishTime)
	}
	if m.remarks != nil {
		fields = append(fields, lessonconfirmation.FieldRemarks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonConfirmationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lessonconfirmation.FieldLessonReservationID:
		return m.LessonReservationID()
	case lessonconfirmation.FieldMatchingDate:
		return m.MatchingDate()
	case lessonconfirmation.FieldStartTime:
		return m.StartTime()
	case lessonconfirmation.FieldFinishTime:
		return m.FinishTime()
	case lessonconfirmation.FieldRemarks:
		return m.Remarks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonConfirmationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lessonconfirmation.FieldLessonReservationID:
		return m.OldLessonReservationID(ctx)
	case lessonconfirmation.FieldMatchingDate:
		return m.OldMatchingDate(ctx)
	case lessonconfirmation.FieldStartTime:
		return m.OldStartTime(ctx)
	case lessonconfirmation.FieldFinishTime:
		return m.OldFinishTime(ctx)
	case lessonconfirmation.FieldRemarks:
		return m.OldRemarks(ctx)
	}
	return nil, fmt.Errorf("unknown LessonConfirmation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonConfirmationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lessonconfirmation.FieldLessonReservationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonReservationID(v)
		return nil
	case lessonconfirmation.FieldMatchingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchingDate(v)
		return nil
	case lessonconfirmation.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case lessonconfirmation.FieldFinishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishTime(v)
		return nil
	case lessonconfirmation.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	}
	return fmt.Errorf("unknown LessonConfirmation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonConfirmationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonConfirmationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonConfirmationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LessonConfirmation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonConfirmationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lessonconfirmation.FieldRemarks) {
		fields = append(fields, lessonconfirmation.FieldRemarks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonConfirmationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonConfirmationMutation) ClearField(name string) error {
	switch name {
	case lessonconfirmation.FieldRemarks:
		m.ClearRemarks()
		return nil
	}
	return fmt.Errorf("unknown LessonConfirmation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonConfirmationMutation) ResetField(name string) error {
	switch name {
	case lessonconfirmation.FieldLessonReservationID:
		m.ResetLessonReservationID()
		return nil
	case lessonconfirmation.FieldMatchingDate:
		m.ResetMatchingDate()
		return nil
	case lessonconfirmation.FieldStartTime:
		m.ResetStartTime()
		return nil
	case lessonconfirmation.FieldFinishTime:
		m.ResetFinishTime()
		return nil
	case lessonconfirmation.FieldRemarks:
		m.ResetRemarks()
		return nil
	}
	return fmt.Errorf("unknown LessonConfirmation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonConfirmationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lesson_reservation != nil {
		edges = append(edges, lessonconfirmation.EdgeLessonReservation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonConfirmationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lessonconfirmation.EdgeLessonReservation:
		if id := m.lesson_reservation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonConfirmationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonConfirmationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonConfirmationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlesson_reservation {
		edges = append(edges, lessonconfirmation.EdgeLessonReservation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonConfirmationMutation) EdgeCleared(name string) bool {
	switch name {
	case lessonconfirmation.EdgeLessonReservation:
		return m.clearedlesson_reservation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonConfirmationMutation) ClearEdge(name string) error {
	switch name {
	case lessonconfirmation.EdgeLessonReservation:
		m.ClearLessonReservation()
		return nil
	}
	return fmt.Errorf("unknown LessonConfirmation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonConfirmationMutation) ResetEdge(name string) error {
	switch name {
	case lessonconfirmation.EdgeLessonReservation:
		m.ResetLessonReservation()
		return nil
	}
	return fmt.Errorf("unknown LessonConfirmation edge %s", name)
}

// LessonPlanMutation represents an operation that mutates the LessonPlan nodes in the graph.
type LessonPlanMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	updated_at                  *time.Time
	title                       *string
	description                 *string
	location                    *string
	lesson_type                 *lessonplan.LessonType
	annual_max_executions       *int
	addannual_max_executions    *int
	start_month                 *int
	addstart_month              *int
	start_day                   *int
	addstart_day                *int
	end_month                   *int
	addend_month                *int
	end_day                     *int
	addend_day                  *int
	start_time                  *time.Time
	end_time                    *time.Time
	clearedFields               map[string]struct{}
	company                     *int
	clearedcompany              bool
	schedules                   map[int]struct{}
	removedschedules            map[int]struct{}
	clearedschedules            bool
	grades                      map[int]struct{}
	removedgrades               map[int]struct{}
	clearedgrades               bool
	subjects                    map[int]struct{}
	removedsubjects             map[int]struct{}
	clearedsubjects             bool
	education_categories        map[int]struct{}
	removededucation_categories map[int]struct{}
	clearededucation_categories bool
	upload_files                map[int]struct{}
	removedupload_files         map[int]struct{}
	clearedupload_files         bool
	done                        bool
	oldValue                    func(context.Context) (*LessonPlan, error)
	predicates                  []predicate.LessonPlan
}

var _ ent.Mutation = (*LessonPlanMutation)(nil)

// lessonplanOption allows management of the mutation configuration using functional options.
type lessonplanOption func(*LessonPlanMutation)

// newLessonPlanMutation creates new mutation for the LessonPlan entity.
func newLessonPlanMutation(c config, op Op, opts ...lessonplanOption) *LessonPlanMutation {
	m := &LessonPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeLessonPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLessonPlanID sets the ID field of the mutation.
func withLessonPlanID(id int) lessonplanOption {
	return func(m *LessonPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *LessonPlan
		)
		m.oldValue = func(ctx context.Context) (*LessonPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LessonPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLessonPlan sets the old LessonPlan of the mutation.
func withLessonPlan(node *LessonPlan) lessonplanOption {
	return func(m *LessonPlanMutation) {
		m.oldValue = func(context.Context) (*LessonPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LessonPlanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LessonPlanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LessonPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LessonPlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LessonPlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LessonPlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LessonPlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LessonPlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LessonPlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCompanyID sets the "company_id" field.
func (m *LessonPlanMutation) SetCompanyID(i int) {
	m.company = &i
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *LessonPlanMutation) CompanyID() (r int, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldCompanyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *LessonPlanMutation) ResetCompanyID() {
	m.company = nil
}

// SetTitle sets the "title" field.
func (m *LessonPlanMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *LessonPlanMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *LessonPlanMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *LessonPlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LessonPlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LessonPlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[lessonplan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LessonPlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[lessonplan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LessonPlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, lessonplan.FieldDescription)
}

// SetLocation sets the "location" field.
func (m *LessonPlanMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *LessonPlanMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *LessonPlanMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[lessonplan.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *LessonPlanMutation) LocationCleared() bool {
	_, ok := m.clearedFields[lessonplan.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *LessonPlanMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, lessonplan.FieldLocation)
}

// SetLessonType sets the "lesson_type" field.
func (m *LessonPlanMutation) SetLessonType(lt lessonplan.LessonType) {
	m.lesson_type = &lt
}

// LessonType returns the value of the "lesson_type" field in the mutation.
func (m *LessonPlanMutation) LessonType() (r lessonplan.LessonType, exists bool) {
	v := m.lesson_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonType returns the old "lesson_type" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldLessonType(ctx context.Context) (v lessonplan.LessonType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonType: %w", err)
	}
	return oldValue.LessonType, nil
}

// ResetLessonType resets all changes to the "lesson_type" field.
func (m *LessonPlanMutation) ResetLessonType() {
	m.lesson_type = nil
}

// SetAnnualMaxExecutions sets the "annual_max_executions" field.
func (m *LessonPlanMutation) SetAnnualMaxExecutions(i int) {
	m.annual_max_executions = &i
	m.addannual_max_executions = nil
}

// AnnualMaxExecutions returns the value of the "annual_max_executions" field in the mutation.
func (m *LessonPlanMutation) AnnualMaxExecutions() (r int, exists bool) {
	v := m.annual_max_executions
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnualMaxExecutions returns the old "annual_max_executions" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldAnnualMaxExecutions(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnualMaxExecutions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnualMaxExecutions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnualMaxExecutions: %w", err)
	}
	return oldValue.AnnualMaxExecutions, nil
}

// AddAnnualMaxExecutions adds i to the "annual_max_executions" field.
func (m *LessonPlanMutation) AddAnnualMaxExecutions(i int) {
	if m.addannual_max_executions != nil {
		*m.addannual_max_executions += i
	} else {
		m.addannual_max_executions = &i
	}
}

// AddedAnnualMaxExecutions returns the value that was added to the "annual_max_executions" field in this mutation.
func (m *LessonPlanMutation) AddedAnnualMaxExecutions() (r int, exists bool) {
	v := m.addannual_max_executions
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnnualMaxExecutions resets all changes to the "annual_max_executions" field.
func (m *LessonPlanMutation) ResetAnnualMaxExecutions() {
	m.annual_max_executions = nil
	m.addannual_max_executions = nil
}

// SetStartMonth sets the "start_month" field.
func (m *LessonPlanMutation) SetStartMonth(i int) {
	m.start_month = &i
	m.addstart_month = nil
}

// StartMonth returns the value of the "start_month" field in the mutation.
func (m *LessonPlanMutation) StartMonth() (r int, exists bool) {
	v := m.start_month
	if v == nil {
		return
	}
	return *v, true
}

// OldStartMonth returns the old "start_month" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldStartMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartMonth: %w", err)
	}
	return oldValue.StartMonth, nil
}

// AddStartMonth adds i to the "start_month" field.
func (m *LessonPlanMutation) AddStartMonth(i int) {
	if m.addstart_month != nil {
		*m.addstart_month += i
	} else {
		m.addstart_month = &i
	}
}

// AddedStartMonth returns the value that was added to the "start_month" field in this mutation.
func (m *LessonPlanMutation) AddedStartMonth() (r int, exists bool) {
	v := m.addstart_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartMonth resets all changes to the "start_month" field.
func (m *LessonPlanMutation) ResetStartMonth() {
	m.start_month = nil
	m.addstart_month = nil
}

// SetStartDay sets the "start_day" field.
func (m *LessonPlanMutation) SetStartDay(i int) {
	m.start_day = &i
	m.addstart_day = nil
}

// StartDay returns the value of the "start_day" field in the mutation.
func (m *LessonPlanMutation) StartDay() (r int, exists bool) {
	v := m.start_day
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDay returns the old "start_day" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldStartDay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDay: %w", err)
	}
	return oldValue.StartDay, nil
}

// AddStartDay adds i to the "start_day" field.
func (m *LessonPlanMutation) AddStartDay(i int) {
	if m.addstart_day != nil {
		*m.addstart_day += i
	} else {
		m.addstart_day = &i
	}
}

// AddedStartDay returns the value that was added to the "start_day" field in this mutation.
func (m *LessonPlanMutation) AddedStartDay() (r int, exists bool) {
	v := m.addstart_day
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartDay resets all changes to the "start_day" field.
func (m *LessonPlanMutation) ResetStartDay() {
	m.start_day = nil
	m.addstart_day = nil
}

// SetEndMonth sets the "end_month" field.
func (m *LessonPlanMutation) SetEndMonth(i int) {
	m.end_month = &i
	m.addend_month = nil
}

// EndMonth returns the value of the "end_month" field in the mutation.
func (m *LessonPlanMutation) EndMonth() (r int, exists bool) {
	v := m.end_month
	if v == nil {
		return
	}
	return *v, true
}

// OldEndMonth returns the old "end_month" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldEndMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndMonth: %w", err)
	}
	return oldValue.EndMonth, nil
}

// AddEndMonth adds i to the "end_month" field.
func (m *LessonPlanMutation) AddEndMonth(i int) {
	if m.addend_month != nil {
		*m.addend_month += i
	} else {
		m.addend_month = &i
	}
}

// AddedEndMonth returns the value that was added to the "end_month" field in this mutation.
func (m *LessonPlanMutation) AddedEndMonth() (r int, exists bool) {
	v := m.addend_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndMonth resets all changes to the "end_month" field.
func (m *LessonPlanMutation) ResetEndMonth() {
	m.end_month = nil
	m.addend_month = nil
}

// SetEndDay sets the "end_day" field.
func (m *LessonPlanMutation) SetEndDay(i int) {
	m.end_day = &i
	m.addend_day = nil
}

// EndDay returns the value of the "end_day" field in the mutation.
func (m *LessonPlanMutation) EndDay() (r int, exists bool) {
	v := m.end_day
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDay returns the old "end_day" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldEndDay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDay: %w", err)
	}
	return oldValue.EndDay, nil
}

// AddEndDay adds i to the "end_day" field.
func (m *LessonPlanMutation) AddEndDay(i int) {
	if m.addend_day != nil {
		*m.addend_day += i
	} else {
		m.addend_day = &i
	}
}

// AddedEndDay returns the value that was added to the "end_day" field in this mutation.
func (m *LessonPlanMutation) AddedEndDay() (r int, exists bool) {
	v := m.addend_day
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndDay resets all changes to the "end_day" field.
func (m *LessonPlanMutation) ResetEndDay() {
	m.end_day = nil
	m.addend_day = nil
}

// SetStartTime sets the "start_time" field.
func (m *LessonPlanMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *LessonPlanMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *LessonPlanMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *LessonPlanMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *LessonPlanMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the LessonPlan entity.
// If the LessonPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonPlanMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *LessonPlanMutation) ResetEndTime() {
	m.end_time = nil
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *LessonPlanMutation) ClearCompany() {
	m.clearedcompany = true
	m.clearedFields[lessonplan.FieldCompanyID] = struct{}{}
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *LessonPlanMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *LessonPlanMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *LessonPlanMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddScheduleIDs adds the "schedules" edge to the LessonSchedule entity by ids.
func (m *LessonPlanMutation) AddScheduleIDs(ids ...int) {
	if m.schedules == nil {
		m.schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// ClearSchedules clears the "schedules" edge to the LessonSchedule entity.
func (m *LessonPlanMutation) ClearSchedules() {
	m.clearedschedules = true
}

// SchedulesCleared reports if the "schedules" edge to the LessonSchedule entity was cleared.
func (m *LessonPlanMutation) SchedulesCleared() bool {
	return m.clearedschedules
}

// RemoveScheduleIDs removes the "schedules" edge to the LessonSchedule entity by IDs.
func (m *LessonPlanMutation) RemoveScheduleIDs(ids ...int) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.schedules, ids[i])
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed IDs of the "schedules" edge to the LessonSchedule entity.
func (m *LessonPlanMutation) RemovedSchedulesIDs() (ids []int) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the "schedules" edge IDs in the mutation.
func (m *LessonPlanMutation) SchedulesIDs() (ids []int) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules resets all changes to the "schedules" edge.
func (m *LessonPlanMutation) ResetSchedules() {
	m.schedules = nil
	m.clearedschedules = false
	m.removedschedules = nil
}

// AddGradeIDs adds the "grades" edge to the Grade entity by ids.
func (m *LessonPlanMutation) AddGradeIDs(ids ...int) {
	if m.grades == nil {
		m.grades = make(map[int]struct{})
	}
	for i := range ids {
		m.grades[ids[i]] = struct{}{}
	}
}

// ClearGrades clears the "grades" edge to the Grade entity.
func (m *LessonPlanMutation) ClearGrades() {
	m.clearedgrades = true
}

// GradesCleared reports if the "grades" edge to the Grade entity was cleared.
func (m *LessonPlanMutation) GradesCleared() bool {
	return m.clearedgrades
}

// RemoveGradeIDs removes the "grades" edge to the Grade entity by IDs.
func (m *LessonPlanMutation) RemoveGradeIDs(ids ...int) {
	if m.removedgrades == nil {
		m.removedgrades = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grades, ids[i])
		m.removedgrades[ids[i]] = struct{}{}
	}
}

// RemovedGrades returns the removed IDs of the "grades" edge to the Grade entity.
func (m *LessonPlanMutation) RemovedGradesIDs() (ids []int) {
	for id := range m.removedgrades {
		ids = append(ids, id)
	}
	return
}

// GradesIDs returns the "grades" edge IDs in the mutation.
func (m *LessonPlanMutation) GradesIDs() (ids []int) {
	for id := range m.grades {
		ids = append(ids, id)
	}
	return
}

// ResetGrades resets all changes to the "grades" edge.
func (m *LessonPlanMutation) ResetGrades() {
	m.grades = nil
	m.clearedgrades = false
	m.removedgrades = nil
}

// AddSubjectIDs adds the "subjects" edge to the Subject entity by ids.
func (m *LessonPlanMutation) AddSubjectIDs(ids ...int) {
	if m.subjects == nil {
		m.subjects = make(map[int]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the Subject entity.
func (m *LessonPlanMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the Subject entity was cleared.
func (m *LessonPlanMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the Subject entity by IDs.
func (m *LessonPlanMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the Subject entity.
func (m *LessonPlanMutation) RemovedSubjectsIDs() (ids []int) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *LessonPlanMutation) SubjectsIDs() (ids []int) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *LessonPlanMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// AddEducationCategoryIDs adds the "education_categories" edge to the EducationCategory entity by ids.
func (m *LessonPlanMutation) AddEducationCategoryIDs(ids ...int) {
	if m.education_categories == nil {
		m.education_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.education_categories[ids[i]] = struct{}{}
	}
}

// ClearEducationCategories clears the "education_categories" edge to the EducationCategory entity.
func (m *LessonPlanMutation) ClearEducationCategories() {
	m.clearededucation_categories = true
}

// EducationCategoriesCleared reports if the "education_categories" edge to the EducationCategory entity was cleared.
func (m *LessonPlanMutation) EducationCategoriesCleared() bool {
	return m.clearededucation_categories
}

// RemoveEducationCategoryIDs removes the "education_categories" edge to the EducationCategory entity by IDs.
func (m *LessonPlanMutation) RemoveEducationCategoryIDs(ids ...int) {
	if m.removededucation_categories == nil {
		m.removededucation_categories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.education_categories, ids[i])
		m.removededucation_categories[ids[i]] = struct{}{}
	}
}

// RemovedEducationCategories returns the removed IDs of the "education_categories" edge to the EducationCategory entity.
func (m *LessonPlanMutation) RemovedEducationCategoriesIDs() (ids []int) {
	for id := range m.removededucation_categories {
		ids = append(ids, id)
	}
	return
}

// EducationCategoriesIDs returns the "education_categories" edge IDs in the mutation.
func (m *LessonPlanMutation) EducationCategoriesIDs() (ids []int) {
	for id := range m.education_categories {
		ids = append(ids, id)
	}
	return
}

// ResetEducationCategories resets all changes to the "education_categories" edge.
func (m *LessonPlanMutation) ResetEducationCategories() {
	m.education_categories = nil
	m.clearededucation_categories = false
	m.removededucation_categories = nil
}

// AddUploadFileIDs adds the "upload_files" edge to the UploadFile entity by ids.
func (m *LessonPlanMutation) AddUploadFileIDs(ids ...int) {
	if m.upload_files == nil {
		m.upload_files = make(map[int]struct{})
	}
	for i := range ids {
		m.upload_files[ids[i]] = struct{}{}
	}
}

// ClearUploadFiles clears the "upload_files" edge to the UploadFile entity.
func (m *LessonPlanMutation) ClearUploadFiles() {
	m.clearedupload_files = true
}

// UploadFilesCleared reports if the "upload_files" edge to the UploadFile entity was cleared.
func (m *LessonPlanMutation) UploadFilesCleared() bool {
	return m.clearedupload_files
}

// RemoveUploadFileIDs removes the "upload_files" edge to the UploadFile entity by IDs.
func (m *LessonPlanMutation) RemoveUploadFileIDs(ids ...int) {
	if m.removedupload_files == nil {
		m.removedupload_files = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.upload_files, ids[i])
		m.removedupload_files[ids[i]] = struct{}{}
	}
}

// RemovedUploadFiles returns the removed IDs of the "upload_files" edge to the UploadFile entity.
func (m *LessonPlanMutation) RemovedUploadFilesIDs() (ids []int) {
	for id := range m.removedupload_files {
		ids = append(ids, id)
	}
	return
}

// UploadFilesIDs returns the "upload_files" edge IDs in the mutation.
func (m *LessonPlanMutation) UploadFilesIDs() (ids []int) {
	for id := range m.upload_files {
		ids = append(ids, id)
	}
	return
}

// ResetUploadFiles resets all changes to the "upload_files" edge.
func (m *LessonPlanMutation) ResetUploadFiles() {
	m.upload_files = nil
	m.clearedupload_files = false
	m.removedupload_files = nil
}

// Where appends a list predicates to the LessonPlanMutation builder.
func (m *LessonPlanMutation) Where(ps ...predicate.LessonPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LessonPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LessonPlan).
func (m *LessonPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonPlanMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, lessonplan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lessonplan.FieldUpdatedAt)
	}
	if m.company != nil {
		fields = append(fields, lessonplan.FieldCompanyID)
	}
	if m.title != nil {
		fields = append(fields, lessonplan.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, lessonplan.FieldDescription)
	}
	if m.location != nil {
		fields = append(fields, lessonplan.FieldLocation)
	}
	if m.lesson_type != nil {
		fields = append(fields, lessonplan.FieldLessonType)
	}
	if m.annual_max_executions != nil {
		fields = append(fields, lessonplan.FieldAnnualMaxExecutions)
	}
	if m.start_month != nil {
		fields = append(fields, lessonplan.FieldStartMonth)
	}
	if m.start_day != nil {
		fields = append(fields, lessonplan.FieldStartDay)
	}
	if m.end_month != nil {
		fields = append(fields, lessonplan.FieldEndMonth)
	}
	if m.end_day != nil {
		fields = append(fields, lessonplan.FieldEndDay)
	}
	if m.start_time != nil {
		fields = append(fields, lessonplan.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, lessonplan.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lessonplan.FieldCreatedAt:
		return m.CreatedAt()
	case lessonplan.FieldUpdatedAt:
		return m.UpdatedAt()
	case lessonplan.FieldCompanyID:
		return m.CompanyID()
	case lessonplan.FieldTitle:
		return m.Title()
	case lessonplan.FieldDescription:
		return m.Description()
	case lessonplan.FieldLocation:
		return m.Location()
	case lessonplan.FieldLessonType:
		return m.LessonType()
	case lessonplan.FieldAnnualMaxExecutions:
		return m.AnnualMaxExecutions()
	case lessonplan.FieldStartMonth:
		return m.StartMonth()
	case lessonplan.FieldStartDay:
		return m.StartDay()
	case lessonplan.FieldEndMonth:
		return m.EndMonth()
	case lessonplan.FieldEndDay:
		return m.EndDay()
	case lessonplan.FieldStartTime:
		return m.StartTime()
	case lessonplan.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lessonplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lessonplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lessonplan.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case lessonplan.FieldTitle:
		return m.OldTitle(ctx)
	case lessonplan.FieldDescription:
		return m.OldDescription(ctx)
	case lessonplan.FieldLocation:
		return m.OldLocation(ctx)
	case lessonplan.FieldLessonType:
		return m.OldLessonType(ctx)
	case lessonplan.FieldAnnualMaxExecutions:
		return m.OldAnnualMaxExecutions(ctx)
	case lessonplan.FieldStartMonth:
		return m.OldStartMonth(ctx)
	case lessonplan.FieldStartDay:
		return m.OldStartDay(ctx)
	case lessonplan.FieldEndMonth:
		return m.OldEndMonth(ctx)
	case lessonplan.FieldEndDay:
		return m.OldEndDay(ctx)
	case lessonplan.FieldStartTime:
		return m.OldStartTime(ctx)
	case lessonplan.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown LessonPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lessonplan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lessonplan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lessonplan.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case lessonplan.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case lessonplan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case lessonplan.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case lessonplan.FieldLessonType:
		v, ok := value.(lessonplan.LessonType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonType(v)
		return nil
	case lessonplan.FieldAnnualMaxExecutions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnualMaxExecutions(v)
		return nil
	case lessonplan.FieldStartMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartMonth(v)
		return nil
	case lessonplan.FieldStartDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDay(v)
		return nil
	case lessonplan.FieldEndMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndMonth(v)
		return nil
	case lessonplan.FieldEndDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDay(v)
		return nil
	case lessonplan.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case lessonplan.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown LessonPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonPlanMutation) AddedFields() []string {
	var fields []string
	if m.addannual_max_executions != nil {
		fields = append(fields, lessonplan.FieldAnnualMaxExecutions)
	}
	if m.addstart_month != nil {
		fields = append(fields, lessonplan.FieldStartMonth)
	}
	if m.addstart_day != nil {
		fields = append(fields, lessonplan.FieldStartDay)
	}
	if m.addend_month != nil {
		fields = append(fields, lessonplan.FieldEndMonth)
	}
	if m.addend_day != nil {
		fields = append(fields, lessonplan.FieldEndDay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonPlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lessonplan.FieldAnnualMaxExecutions:
		return m.AddedAnnualMaxExecutions()
	case lessonplan.FieldStartMonth:
		return m.AddedStartMonth()
	case lessonplan.FieldStartDay:
		return m.AddedStartDay()
	case lessonplan.FieldEndMonth:
		return m.AddedEndMonth()
	case lessonplan.FieldEndDay:
		return m.AddedEndDay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lessonplan.FieldAnnualMaxExecutions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnnualMaxExecutions(v)
		return nil
	case lessonplan.FieldStartMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartMonth(v)
		return nil
	case lessonplan.FieldStartDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartDay(v)
		return nil
	case lessonplan.FieldEndMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndMonth(v)
		return nil
	case lessonplan.FieldEndDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndDay(v)
		return nil
	}
	return fmt.Errorf("unknown LessonPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lessonplan.FieldDescription) {
		fields = append(fields, lessonplan.FieldDescription)
	}
	if m.FieldCleared(lessonplan.FieldLocation) {
		fields = append(fields, lessonplan.FieldLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonPlanMutation) ClearField(name string) error {
	switch name {
	case lessonplan.FieldDescription:
		m.ClearDescription()
		return nil
	case lessonplan.FieldLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown LessonPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonPlanMutation) ResetField(name string) error {
	switch name {
	case lessonplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lessonplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lessonplan.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case lessonplan.FieldTitle:
		m.ResetTitle()
		return nil
	case lessonplan.FieldDescription:
		m.ResetDescription()
		return nil
	case lessonplan.FieldLocation:
		m.ResetLocation()
		return nil
	case lessonplan.FieldLessonType:
		m.ResetLessonType()
		return nil
	case lessonplan.FieldAnnualMaxExecutions:
		m.ResetAnnualMaxExecutions()
		return nil
	case lessonplan.FieldStartMonth:
		m.ResetStartMonth()
		return nil
	case lessonplan.FieldStartDay:
		m.ResetStartDay()
		return nil
	case lessonplan.FieldEndMonth:
		m.ResetEndMonth()
		return nil
	case lessonplan.FieldEndDay:
		m.ResetEndDay()
		return nil
	case lessonplan.FieldStartTime:
		m.ResetStartTime()
		return nil
	case lessonplan.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown LessonPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.company != nil {
		edges = append(edges, lessonplan.EdgeCompany)
	}
	if m.schedules != nil {
		edges = append(edges, lessonplan.EdgeSchedules)
	}
	if m.grades != nil {
		edges = append(edges, lessonplan.EdgeGrades)
	}
	if m.subjects != nil {
		edges = append(edges, lessonplan.EdgeSubjects)
	}
	if m.education_categories != nil {
		edges = append(edges, lessonplan.EdgeEducationCategories)
	}
	if m.upload_files != nil {
		edges = append(edges, lessonplan.EdgeUploadFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lessonplan.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case lessonplan.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	case lessonplan.EdgeGrades:
		ids := make([]ent.Value, 0, len(m.grades))
		for id := range m.grades {
			ids = append(ids, id)
		}
		return ids
	case lessonplan.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	case lessonplan.EdgeEducationCategories:
		ids := make([]ent.Value, 0, len(m.education_categories))
		for id := range m.education_categories {
			ids = append(ids, id)
		}
		return ids
	case lessonplan.EdgeUploadFiles:
		ids := make([]ent.Value, 0, len(m.upload_files))
		for id := range m.upload_files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedschedules != nil {
		edges = append(edges, lessonplan.EdgeSchedules)
	}
	if m.removedgrades != nil {
		edges = append(edges, lessonplan.EdgeGrades)
	}
	if m.removedsubjects != nil {
		edges = append(edges, lessonplan.EdgeSubjects)
	}
	if m.removededucation_categories != nil {
		edges = append(edges, lessonplan.EdgeEducationCategories)
	}
	if m.removedupload_files != nil {
		edges = append(edges, lessonplan.EdgeUploadFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonPlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lessonplan.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	case lessonplan.EdgeGrades:
		ids := make([]ent.Value, 0, len(m.removedgrades))
		for id := range m.removedgrades {
			ids = append(ids, id)
		}
		return ids
	case lessonplan.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	case lessonplan.EdgeEducationCategories:
		ids := make([]ent.Value, 0, len(m.removededucation_categories))
		for id := range m.removededucation_categories {
			ids = append(ids, id)
		}
		return ids
	case lessonplan.EdgeUploadFiles:
		ids := make([]ent.Value, 0, len(m.removedupload_files))
		for id := range m.removedupload_files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcompany {
		edges = append(edges, lessonplan.EdgeCompany)
	}
	if m.clearedschedules {
		edges = append(edges, lessonplan.EdgeSchedules)
	}
	if m.clearedgrades {
		edges = append(edges, lessonplan.EdgeGrades)
	}
	if m.clearedsubjects {
		edges = append(edges, lessonplan.EdgeSubjects)
	}
	if m.clearededucation_categories {
		edges = append(edges, lessonplan.EdgeEducationCategories)
	}
	if m.clearedupload_files {
		edges = append(edges, lessonplan.EdgeUploadFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case lessonplan.EdgeCompany:
		return m.clearedcompany
	case lessonplan.EdgeSchedules:
		return m.clearedschedules
	case lessonplan.EdgeGrades:
		return m.clearedgrades
	case lessonplan.EdgeSubjects:
		return m.clearedsubjects
	case lessonplan.EdgeEducationCategories:
		return m.clearededucation_categories
	case lessonplan.EdgeUploadFiles:
		return m.clearedupload_files
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonPlanMutation) ClearEdge(name string) error {
	switch name {
	case lessonplan.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown LessonPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonPlanMutation) ResetEdge(name string) error {
	switch name {
	case lessonplan.EdgeCompany:
		m.ResetCompany()
		return nil
	case lessonplan.EdgeSchedules:
		m.ResetSchedules()
		return nil
	case lessonplan.EdgeGrades:
		m.ResetGrades()
		return nil
	case lessonplan.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case lessonplan.EdgeEducationCategories:
		m.ResetEducationCategories()
		return nil
	case lessonplan.EdgeUploadFiles:
		m.ResetUploadFiles()
		return nil
	}
	return fmt.Errorf("unknown LessonPlan edge %s", name)
}

// LessonReservationMutation represents an operation that mutates the LessonReservation nodes in the graph.
type LessonReservationMutation struct {
	config
	op                                        Op
	typ                                       string
	id                                        *int
	reservation_status                        *lessonreservation.ReservationStatus
	count_student                             *string
	graduate                                  *string
	subject                                   *string
	remarks                                   *string
	reservation_confirm_at                    *time.Time
	clearedFields                             map[string]struct{}
	lesson_schedule                           *int
	clearedlesson_schedule                    bool
	school                                    *int
	clearedschool                             bool
	user                                      *int
	cleareduser                               bool
	lesson_reservation_preferred_dates        map[int]struct{}
	removedlesson_reservation_preferred_dates map[int]struct{}
	clearedlesson_reservation_preferred_dates bool
	lesson_confirmation                       map[int]struct{}
	removedlesson_confirmation                map[int]struct{}
	clearedlesson_confirmation                bool
	done                                      bool
	oldValue                                  func(context.Context) (*LessonReservation, error)
	predicates                                []predicate.LessonReservation
}

var _ ent.Mutation = (*LessonReservationMutation)(nil)

// lessonreservationOption allows management of the mutation configuration using functional options.
type lessonreservationOption func(*LessonReservationMutation)

// newLessonReservationMutation creates new mutation for the LessonReservation entity.
func newLessonReservationMutation(c config, op Op, opts ...lessonreservationOption) *LessonReservationMutation {
	m := &LessonReservationMutation{
		config:        c,
		op:            op,
		typ:           TypeLessonReservation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLessonReservationID sets the ID field of the mutation.
func withLessonReservationID(id int) lessonreservationOption {
	return func(m *LessonReservationMutation) {
		var (
			err   error
			once  sync.Once
			value *LessonReservation
		)
		m.oldValue = func(ctx context.Context) (*LessonReservation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LessonReservation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLessonReservation sets the old LessonReservation of the mutation.
func withLessonReservation(node *LessonReservation) lessonreservationOption {
	return func(m *LessonReservationMutation) {
		m.oldValue = func(context.Context) (*LessonReservation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonReservationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonReservationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LessonReservationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LessonReservationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LessonReservation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLessonScheduleID sets the "lesson_schedule_id" field.
func (m *LessonReservationMutation) SetLessonScheduleID(i int) {
	m.lesson_schedule = &i
}

// LessonScheduleID returns the value of the "lesson_schedule_id" field in the mutation.
func (m *LessonReservationMutation) LessonScheduleID() (r int, exists bool) {
	v := m.lesson_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonScheduleID returns the old "lesson_schedule_id" field's value of the LessonReservation entity.
// If the LessonReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationMutation) OldLessonScheduleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonScheduleID: %w", err)
	}
	return oldValue.LessonScheduleID, nil
}

// ResetLessonScheduleID resets all changes to the "lesson_schedule_id" field.
func (m *LessonReservationMutation) ResetLessonScheduleID() {
	m.lesson_schedule = nil
}

// SetSchoolID sets the "school_id" field.
func (m *LessonReservationMutation) SetSchoolID(i int) {
	m.school = &i
}

// SchoolID returns the value of the "school_id" field in the mutation.
func (m *LessonReservationMutation) SchoolID() (r int, exists bool) {
	v := m.school
	if v == nil {
		return
	}
	return *v, true
}

// OldSchoolID returns the old "school_id" field's value of the LessonReservation entity.
// If the LessonReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationMutation) OldSchoolID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchoolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchoolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchoolID: %w", err)
	}
	return oldValue.SchoolID, nil
}

// ResetSchoolID resets all changes to the "school_id" field.
func (m *LessonReservationMutation) ResetSchoolID() {
	m.school = nil
}

// SetUserID sets the "user_id" field.
func (m *LessonReservationMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LessonReservationMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LessonReservation entity.
// If the LessonReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LessonReservationMutation) ResetUserID() {
	m.user = nil
}

// SetReservationStatus sets the "reservation_status" field.
func (m *LessonReservationMutation) SetReservationStatus(ls lessonreservation.ReservationStatus) {
	m.reservation_status = &ls
}

// ReservationStatus returns the value of the "reservation_status" field in the mutation.
func (m *LessonReservationMutation) ReservationStatus() (r lessonreservation.ReservationStatus, exists bool) {
	v := m.reservation_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationStatus returns the old "reservation_status" field's value of the LessonReservation entity.
// If the LessonReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationMutation) OldReservationStatus(ctx context.Context) (v lessonreservation.ReservationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationStatus: %w", err)
	}
	return oldValue.ReservationStatus, nil
}

// ResetReservationStatus resets all changes to the "reservation_status" field.
func (m *LessonReservationMutation) ResetReservationStatus() {
	m.reservation_status = nil
}

// SetCountStudent sets the "count_student" field.
func (m *LessonReservationMutation) SetCountStudent(s string) {
	m.count_student = &s
}

// CountStudent returns the value of the "count_student" field in the mutation.
func (m *LessonReservationMutation) CountStudent() (r string, exists bool) {
	v := m.count_student
	if v == nil {
		return
	}
	return *v, true
}

// OldCountStudent returns the old "count_student" field's value of the LessonReservation entity.
// If the LessonReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationMutation) OldCountStudent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountStudent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountStudent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountStudent: %w", err)
	}
	return oldValue.CountStudent, nil
}

// ResetCountStudent resets all changes to the "count_student" field.
func (m *LessonReservationMutation) ResetCountStudent() {
	m.count_student = nil
}

// SetGraduate sets the "graduate" field.
func (m *LessonReservationMutation) SetGraduate(s string) {
	m.graduate = &s
}

// Graduate returns the value of the "graduate" field in the mutation.
func (m *LessonReservationMutation) Graduate() (r string, exists bool) {
	v := m.graduate
	if v == nil {
		return
	}
	return *v, true
}

// OldGraduate returns the old "graduate" field's value of the LessonReservation entity.
// If the LessonReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationMutation) OldGraduate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGraduate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGraduate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGraduate: %w", err)
	}
	return oldValue.Graduate, nil
}

// ResetGraduate resets all changes to the "graduate" field.
func (m *LessonReservationMutation) ResetGraduate() {
	m.graduate = nil
}

// SetSubject sets the "subject" field.
func (m *LessonReservationMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *LessonReservationMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the LessonReservation entity.
// If the LessonReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *LessonReservationMutation) ResetSubject() {
	m.subject = nil
}

// SetRemarks sets the "remarks" field.
func (m *LessonReservationMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the value of the "remarks" field in the mutation.
func (m *LessonReservationMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old "remarks" field's value of the LessonReservation entity.
// If the LessonReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationMutation) OldRemarks(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of the "remarks" field.
func (m *LessonReservationMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[lessonreservation.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the "remarks" field was cleared in this mutation.
func (m *LessonReservationMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[lessonreservation.FieldRemarks]
	return ok
}

// ResetRemarks resets all changes to the "remarks" field.
func (m *LessonReservationMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, lessonreservation.FieldRemarks)
}

// SetReservationConfirmAt sets the "reservation_confirm_at" field.
func (m *LessonReservationMutation) SetReservationConfirmAt(t time.Time) {
	m.reservation_confirm_at = &t
}

// ReservationConfirmAt returns the value of the "reservation_confirm_at" field in the mutation.
func (m *LessonReservationMutation) ReservationConfirmAt() (r time.Time, exists bool) {
	v := m.reservation_confirm_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationConfirmAt returns the old "reservation_confirm_at" field's value of the LessonReservation entity.
// If the LessonReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationMutation) OldReservationConfirmAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationConfirmAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationConfirmAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationConfirmAt: %w", err)
	}
	return oldValue.ReservationConfirmAt, nil
}

// ClearReservationConfirmAt clears the value of the "reservation_confirm_at" field.
func (m *LessonReservationMutation) ClearReservationConfirmAt() {
	m.reservation_confirm_at = nil
	m.clearedFields[lessonreservation.FieldReservationConfirmAt] = struct{}{}
}

// ReservationConfirmAtCleared returns if the "reservation_confirm_at" field was cleared in this mutation.
func (m *LessonReservationMutation) ReservationConfirmAtCleared() bool {
	_, ok := m.clearedFields[lessonreservation.FieldReservationConfirmAt]
	return ok
}

// ResetReservationConfirmAt resets all changes to the "reservation_confirm_at" field.
func (m *LessonReservationMutation) ResetReservationConfirmAt() {
	m.reservation_confirm_at = nil
	delete(m.clearedFields, lessonreservation.FieldReservationConfirmAt)
}

// ClearLessonSchedule clears the "lesson_schedule" edge to the LessonSchedule entity.
func (m *LessonReservationMutation) ClearLessonSchedule() {
	m.clearedlesson_schedule = true
	m.clearedFields[lessonreservation.FieldLessonScheduleID] = struct{}{}
}

// LessonScheduleCleared reports if the "lesson_schedule" edge to the LessonSchedule entity was cleared.
func (m *LessonReservationMutation) LessonScheduleCleared() bool {
	return m.clearedlesson_schedule
}

// LessonScheduleIDs returns the "lesson_schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LessonScheduleID instead. It exists only for internal usage by the builders.
func (m *LessonReservationMutation) LessonScheduleIDs() (ids []int) {
	if id := m.lesson_schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLessonSchedule resets all changes to the "lesson_schedule" edge.
func (m *LessonReservationMutation) ResetLessonSchedule() {
	m.lesson_schedule = nil
	m.clearedlesson_schedule = false
}

// ClearSchool clears the "school" edge to the School entity.
func (m *LessonReservationMutation) ClearSchool() {
	m.clearedschool = true
	m.clearedFields[lessonreservation.FieldSchoolID] = struct{}{}
}

// SchoolCleared reports if the "school" edge to the School entity was cleared.
func (m *LessonReservationMutation) SchoolCleared() bool {
	return m.clearedschool
}

// SchoolIDs returns the "school" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchoolID instead. It exists only for internal usage by the builders.
func (m *LessonReservationMutation) SchoolIDs() (ids []int) {
	if id := m.school; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchool resets all changes to the "school" edge.
func (m *LessonReservationMutation) ResetSchool() {
	m.school = nil
	m.clearedschool = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *LessonReservationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[lessonreservation.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LessonReservationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LessonReservationMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LessonReservationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddLessonReservationPreferredDateIDs adds the "lesson_reservation_preferred_dates" edge to the LessonReservationPreferredDate entity by ids.
func (m *LessonReservationMutation) AddLessonReservationPreferredDateIDs(ids ...int) {
	if m.lesson_reservation_preferred_dates == nil {
		m.lesson_reservation_preferred_dates = make(map[int]struct{})
	}
	for i := range ids {
		m.lesson_reservation_preferred_dates[ids[i]] = struct{}{}
	}
}

// ClearLessonReservationPreferredDates clears the "lesson_reservation_preferred_dates" edge to the LessonReservationPreferredDate entity.
func (m *LessonReservationMutation) ClearLessonReservationPreferredDates() {
	m.clearedlesson_reservation_preferred_dates = true
}

// LessonReservationPreferredDatesCleared reports if the "lesson_reservation_preferred_dates" edge to the LessonReservationPreferredDate entity was cleared.
func (m *LessonReservationMutation) LessonReservationPreferredDatesCleared() bool {
	return m.clearedlesson_reservation_preferred_dates
}

// RemoveLessonReservationPreferredDateIDs removes the "lesson_reservation_preferred_dates" edge to the LessonReservationPreferredDate entity by IDs.
func (m *LessonReservationMutation) RemoveLessonReservationPreferredDateIDs(ids ...int) {
	if m.removedlesson_reservation_preferred_dates == nil {
		m.removedlesson_reservation_preferred_dates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lesson_reservation_preferred_dates, ids[i])
		m.removedlesson_reservation_preferred_dates[ids[i]] = struct{}{}
	}
}

// RemovedLessonReservationPreferredDates returns the removed IDs of the "lesson_reservation_preferred_dates" edge to the LessonReservationPreferredDate entity.
func (m *LessonReservationMutation) RemovedLessonReservationPreferredDatesIDs() (ids []int) {
	for id := range m.removedlesson_reservation_preferred_dates {
		ids = append(ids, id)
	}
	return
}

// LessonReservationPreferredDatesIDs returns the "lesson_reservation_preferred_dates" edge IDs in the mutation.
func (m *LessonReservationMutation) LessonReservationPreferredDatesIDs() (ids []int) {
	for id := range m.lesson_reservation_preferred_dates {
		ids = append(ids, id)
	}
	return
}

// ResetLessonReservationPreferredDates resets all changes to the "lesson_reservation_preferred_dates" edge.
func (m *LessonReservationMutation) ResetLessonReservationPreferredDates() {
	m.lesson_reservation_preferred_dates = nil
	m.clearedlesson_reservation_preferred_dates = false
	m.removedlesson_reservation_preferred_dates = nil
}

// AddLessonConfirmationIDs adds the "lesson_confirmation" edge to the LessonConfirmation entity by ids.
func (m *LessonReservationMutation) AddLessonConfirmationIDs(ids ...int) {
	if m.lesson_confirmation == nil {
		m.lesson_confirmation = make(map[int]struct{})
	}
	for i := range ids {
		m.lesson_confirmation[ids[i]] = struct{}{}
	}
}

// ClearLessonConfirmation clears the "lesson_confirmation" edge to the LessonConfirmation entity.
func (m *LessonReservationMutation) ClearLessonConfirmation() {
	m.clearedlesson_confirmation = true
}

// LessonConfirmationCleared reports if the "lesson_confirmation" edge to the LessonConfirmation entity was cleared.
func (m *LessonReservationMutation) LessonConfirmationCleared() bool {
	return m.clearedlesson_confirmation
}

// RemoveLessonConfirmationIDs removes the "lesson_confirmation" edge to the LessonConfirmation entity by IDs.
func (m *LessonReservationMutation) RemoveLessonConfirmationIDs(ids ...int) {
	if m.removedlesson_confirmation == nil {
		m.removedlesson_confirmation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lesson_confirmation, ids[i])
		m.removedlesson_confirmation[ids[i]] = struct{}{}
	}
}

// RemovedLessonConfirmation returns the removed IDs of the "lesson_confirmation" edge to the LessonConfirmation entity.
func (m *LessonReservationMutation) RemovedLessonConfirmationIDs() (ids []int) {
	for id := range m.removedlesson_confirmation {
		ids = append(ids, id)
	}
	return
}

// LessonConfirmationIDs returns the "lesson_confirmation" edge IDs in the mutation.
func (m *LessonReservationMutation) LessonConfirmationIDs() (ids []int) {
	for id := range m.lesson_confirmation {
		ids = append(ids, id)
	}
	return
}

// ResetLessonConfirmation resets all changes to the "lesson_confirmation" edge.
func (m *LessonReservationMutation) ResetLessonConfirmation() {
	m.lesson_confirmation = nil
	m.clearedlesson_confirmation = false
	m.removedlesson_confirmation = nil
}

// Where appends a list predicates to the LessonReservationMutation builder.
func (m *LessonReservationMutation) Where(ps ...predicate.LessonReservation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonReservationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonReservationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LessonReservation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonReservationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonReservationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LessonReservation).
func (m *LessonReservationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonReservationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.lesson_schedule != nil {
		fields = append(fields, lessonreservation.FieldLessonScheduleID)
	}
	if m.school != nil {
		fields = append(fields, lessonreservation.FieldSchoolID)
	}
	if m.user != nil {
		fields = append(fields, lessonreservation.FieldUserID)
	}
	if m.reservation_status != nil {
		fields = append(fields, lessonreservation.FieldReservationStatus)
	}
	if m.count_student != nil {
		fields = append(fields, lessonreservation.FieldCountStudent)
	}
	if m.graduate != nil {
		fields = append(fields, lessonreservation.FieldGraduate)
	}
	if m.subject != nil {
		fields = append(fields, lessonreservation.FieldSubject)
	}
	if m.remarks != nil {
		fields = append(fields, lessonreservation.FieldRemarks)
	}
	if m.reservation_confirm_at != nil {
		fields = append(fields, lessonreservation.FieldReservationConfirmAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonReservationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lessonreservation.FieldLessonScheduleID:
		return m.LessonScheduleID()
	case lessonreservation.FieldSchoolID:
		return m.SchoolID()
	case lessonreservation.FieldUserID:
		return m.UserID()
	case lessonreservation.FieldReservationStatus:
		return m.ReservationStatus()
	case lessonreservation.FieldCountStudent:
		return m.CountStudent()
	case lessonreservation.FieldGraduate:
		return m.Graduate()
	case lessonreservation.FieldSubject:
		return m.Subject()
	case lessonreservation.FieldRemarks:
		return m.Remarks()
	case lessonreservation.FieldReservationConfirmAt:
		return m.ReservationConfirmAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonReservationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lessonreservation.FieldLessonScheduleID:
		return m.OldLessonScheduleID(ctx)
	case lessonreservation.FieldSchoolID:
		return m.OldSchoolID(ctx)
	case lessonreservation.FieldUserID:
		return m.OldUserID(ctx)
	case lessonreservation.FieldReservationStatus:
		return m.OldReservationStatus(ctx)
	case lessonreservation.FieldCountStudent:
		return m.OldCountStudent(ctx)
	case lessonreservation.FieldGraduate:
		return m.OldGraduate(ctx)
	case lessonreservation.FieldSubject:
		return m.OldSubject(ctx)
	case lessonreservation.FieldRemarks:
		return m.OldRemarks(ctx)
	case lessonreservation.FieldReservationConfirmAt:
		return m.OldReservationConfirmAt(ctx)
	}
	return nil, fmt.Errorf("unknown LessonReservation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonReservationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lessonreservation.FieldLessonScheduleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonScheduleID(v)
		return nil
	case lessonreservation.FieldSchoolID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchoolID(v)
		return nil
	case lessonreservation.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case lessonreservation.FieldReservationStatus:
		v, ok := value.(lessonreservation.ReservationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationStatus(v)
		return nil
	case lessonreservation.FieldCountStudent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountStudent(v)
		return nil
	case lessonreservation.FieldGraduate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGraduate(v)
		return nil
	case lessonreservation.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case lessonreservation.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case lessonreservation.FieldReservationConfirmAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationConfirmAt(v)
		return nil
	}
	return fmt.Errorf("unknown LessonReservation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonReservationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonReservationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonReservationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LessonReservation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonReservationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lessonreservation.FieldRemarks) {
		fields = append(fields, lessonreservation.FieldRemarks)
	}
	if m.FieldCleared(lessonreservation.FieldReservationConfirmAt) {
		fields = append(fields, lessonreservation.FieldReservationConfirmAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonReservationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonReservationMutation) ClearField(name string) error {
	switch name {
	case lessonreservation.FieldRemarks:
		m.ClearRemarks()
		return nil
	case lessonreservation.FieldReservationConfirmAt:
		m.ClearReservationConfirmAt()
		return nil
	}
	return fmt.Errorf("unknown LessonReservation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonReservationMutation) ResetField(name string) error {
	switch name {
	case lessonreservation.FieldLessonScheduleID:
		m.ResetLessonScheduleID()
		return nil
	case lessonreservation.FieldSchoolID:
		m.ResetSchoolID()
		return nil
	case lessonreservation.FieldUserID:
		m.ResetUserID()
		return nil
	case lessonreservation.FieldReservationStatus:
		m.ResetReservationStatus()
		return nil
	case lessonreservation.FieldCountStudent:
		m.ResetCountStudent()
		return nil
	case lessonreservation.FieldGraduate:
		m.ResetGraduate()
		return nil
	case lessonreservation.FieldSubject:
		m.ResetSubject()
		return nil
	case lessonreservation.FieldRemarks:
		m.ResetRemarks()
		return nil
	case lessonreservation.FieldReservationConfirmAt:
		m.ResetReservationConfirmAt()
		return nil
	}
	return fmt.Errorf("unknown LessonReservation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonReservationMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.lesson_schedule != nil {
		edges = append(edges, lessonreservation.EdgeLessonSchedule)
	}
	if m.school != nil {
		edges = append(edges, lessonreservation.EdgeSchool)
	}
	if m.user != nil {
		edges = append(edges, lessonreservation.EdgeUser)
	}
	if m.lesson_reservation_preferred_dates != nil {
		edges = append(edges, lessonreservation.EdgeLessonReservationPreferredDates)
	}
	if m.lesson_confirmation != nil {
		edges = append(edges, lessonreservation.EdgeLessonConfirmation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonReservationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lessonreservation.EdgeLessonSchedule:
		if id := m.lesson_schedule; id != nil {
			return []ent.Value{*id}
		}
	case lessonreservation.EdgeSchool:
		if id := m.school; id != nil {
			return []ent.Value{*id}
		}
	case lessonreservation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case lessonreservation.EdgeLessonReservationPreferredDates:
		ids := make([]ent.Value, 0, len(m.lesson_reservation_preferred_dates))
		for id := range m.lesson_reservation_preferred_dates {
			ids = append(ids, id)
		}
		return ids
	case lessonreservation.EdgeLessonConfirmation:
		ids := make([]ent.Value, 0, len(m.lesson_confirmation))
		for id := range m.lesson_confirmation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonReservationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedlesson_reservation_preferred_dates != nil {
		edges = append(edges, lessonreservation.EdgeLessonReservationPreferredDates)
	}
	if m.removedlesson_confirmation != nil {
		edges = append(edges, lessonreservation.EdgeLessonConfirmation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonReservationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lessonreservation.EdgeLessonReservationPreferredDates:
		ids := make([]ent.Value, 0, len(m.removedlesson_reservation_preferred_dates))
		for id := range m.removedlesson_reservation_preferred_dates {
			ids = append(ids, id)
		}
		return ids
	case lessonreservation.EdgeLessonConfirmation:
		ids := make([]ent.Value, 0, len(m.removedlesson_confirmation))
		for id := range m.removedlesson_confirmation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonReservationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedlesson_schedule {
		edges = append(edges, lessonreservation.EdgeLessonSchedule)
	}
	if m.clearedschool {
		edges = append(edges, lessonreservation.EdgeSchool)
	}
	if m.cleareduser {
		edges = append(edges, lessonreservation.EdgeUser)
	}
	if m.clearedlesson_reservation_preferred_dates {
		edges = append(edges, lessonreservation.EdgeLessonReservationPreferredDates)
	}
	if m.clearedlesson_confirmation {
		edges = append(edges, lessonreservation.EdgeLessonConfirmation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonReservationMutation) EdgeCleared(name string) bool {
	switch name {
	case lessonreservation.EdgeLessonSchedule:
		return m.clearedlesson_schedule
	case lessonreservation.EdgeSchool:
		return m.clearedschool
	case lessonreservation.EdgeUser:
		return m.cleareduser
	case lessonreservation.EdgeLessonReservationPreferredDates:
		return m.clearedlesson_reservation_preferred_dates
	case lessonreservation.EdgeLessonConfirmation:
		return m.clearedlesson_confirmation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonReservationMutation) ClearEdge(name string) error {
	switch name {
	case lessonreservation.EdgeLessonSchedule:
		m.ClearLessonSchedule()
		return nil
	case lessonreservation.EdgeSchool:
		m.ClearSchool()
		return nil
	case lessonreservation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown LessonReservation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonReservationMutation) ResetEdge(name string) error {
	switch name {
	case lessonreservation.EdgeLessonSchedule:
		m.ResetLessonSchedule()
		return nil
	case lessonreservation.EdgeSchool:
		m.ResetSchool()
		return nil
	case lessonreservation.EdgeUser:
		m.ResetUser()
		return nil
	case lessonreservation.EdgeLessonReservationPreferredDates:
		m.ResetLessonReservationPreferredDates()
		return nil
	case lessonreservation.EdgeLessonConfirmation:
		m.ResetLessonConfirmation()
		return nil
	}
	return fmt.Errorf("unknown LessonReservation edge %s", name)
}

// LessonReservationPreferredDateMutation represents an operation that mutates the LessonReservationPreferredDate nodes in the graph.
type LessonReservationPreferredDateMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_at                *time.Time
	updated_at                *time.Time
	priority                  *lessonreservationpreferreddate.Priority
	date                      *time.Time
	start_time                *time.Time
	end_time                  *time.Time
	clearedFields             map[string]struct{}
	lessonReservations        *int
	clearedlessonReservations bool
	done                      bool
	oldValue                  func(context.Context) (*LessonReservationPreferredDate, error)
	predicates                []predicate.LessonReservationPreferredDate
}

var _ ent.Mutation = (*LessonReservationPreferredDateMutation)(nil)

// lessonreservationpreferreddateOption allows management of the mutation configuration using functional options.
type lessonreservationpreferreddateOption func(*LessonReservationPreferredDateMutation)

// newLessonReservationPreferredDateMutation creates new mutation for the LessonReservationPreferredDate entity.
func newLessonReservationPreferredDateMutation(c config, op Op, opts ...lessonreservationpreferreddateOption) *LessonReservationPreferredDateMutation {
	m := &LessonReservationPreferredDateMutation{
		config:        c,
		op:            op,
		typ:           TypeLessonReservationPreferredDate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLessonReservationPreferredDateID sets the ID field of the mutation.
func withLessonReservationPreferredDateID(id int) lessonreservationpreferreddateOption {
	return func(m *LessonReservationPreferredDateMutation) {
		var (
			err   error
			once  sync.Once
			value *LessonReservationPreferredDate
		)
		m.oldValue = func(ctx context.Context) (*LessonReservationPreferredDate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LessonReservationPreferredDate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLessonReservationPreferredDate sets the old LessonReservationPreferredDate of the mutation.
func withLessonReservationPreferredDate(node *LessonReservationPreferredDate) lessonreservationpreferreddateOption {
	return func(m *LessonReservationPreferredDateMutation) {
		m.oldValue = func(context.Context) (*LessonReservationPreferredDate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonReservationPreferredDateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonReservationPreferredDateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LessonReservationPreferredDateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LessonReservationPreferredDateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LessonReservationPreferredDate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LessonReservationPreferredDateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LessonReservationPreferredDateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LessonReservationPreferredDate entity.
// If the LessonReservationPreferredDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationPreferredDateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LessonReservationPreferredDateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LessonReservationPreferredDateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LessonReservationPreferredDateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LessonReservationPreferredDate entity.
// If the LessonReservationPreferredDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationPreferredDateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LessonReservationPreferredDateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLessonReservationID sets the "lesson_reservation_id" field.
func (m *LessonReservationPreferredDateMutation) SetLessonReservationID(i int) {
	m.lessonReservations = &i
}

// LessonReservationID returns the value of the "lesson_reservation_id" field in the mutation.
func (m *LessonReservationPreferredDateMutation) LessonReservationID() (r int, exists bool) {
	v := m.lessonReservations
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonReservationID returns the old "lesson_reservation_id" field's value of the LessonReservationPreferredDate entity.
// If the LessonReservationPreferredDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationPreferredDateMutation) OldLessonReservationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonReservationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonReservationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonReservationID: %w", err)
	}
	return oldValue.LessonReservationID, nil
}

// ResetLessonReservationID resets all changes to the "lesson_reservation_id" field.
func (m *LessonReservationPreferredDateMutation) ResetLessonReservationID() {
	m.lessonReservations = nil
}

// SetPriority sets the "priority" field.
func (m *LessonReservationPreferredDateMutation) SetPriority(l lessonreservationpreferreddate.Priority) {
	m.priority = &l
}

// Priority returns the value of the "priority" field in the mutation.
func (m *LessonReservationPreferredDateMutation) Priority() (r lessonreservationpreferreddate.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the LessonReservationPreferredDate entity.
// If the LessonReservationPreferredDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationPreferredDateMutation) OldPriority(ctx context.Context) (v lessonreservationpreferreddate.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *LessonReservationPreferredDateMutation) ResetPriority() {
	m.priority = nil
}

// SetDate sets the "date" field.
func (m *LessonReservationPreferredDateMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *LessonReservationPreferredDateMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the LessonReservationPreferredDate entity.
// If the LessonReservationPreferredDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationPreferredDateMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *LessonReservationPreferredDateMutation) ResetDate() {
	m.date = nil
}

// SetStartTime sets the "start_time" field.
func (m *LessonReservationPreferredDateMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *LessonReservationPreferredDateMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the LessonReservationPreferredDate entity.
// If the LessonReservationPreferredDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationPreferredDateMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *LessonReservationPreferredDateMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *LessonReservationPreferredDateMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *LessonReservationPreferredDateMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the LessonReservationPreferredDate entity.
// If the LessonReservationPreferredDate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonReservationPreferredDateMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *LessonReservationPreferredDateMutation) ResetEndTime() {
	m.end_time = nil
}

// SetLessonReservationsID sets the "lessonReservations" edge to the LessonReservation entity by id.
func (m *LessonReservationPreferredDateMutation) SetLessonReservationsID(id int) {
	m.lessonReservations = &id
}

// ClearLessonReservations clears the "lessonReservations" edge to the LessonReservation entity.
func (m *LessonReservationPreferredDateMutation) ClearLessonReservations() {
	m.clearedlessonReservations = true
	m.clearedFields[lessonreservationpreferreddate.FieldLessonReservationID] = struct{}{}
}

// LessonReservationsCleared reports if the "lessonReservations" edge to the LessonReservation entity was cleared.
func (m *LessonReservationPreferredDateMutation) LessonReservationsCleared() bool {
	return m.clearedlessonReservations
}

// LessonReservationsID returns the "lessonReservations" edge ID in the mutation.
func (m *LessonReservationPreferredDateMutation) LessonReservationsID() (id int, exists bool) {
	if m.lessonReservations != nil {
		return *m.lessonReservations, true
	}
	return
}

// LessonReservationsIDs returns the "lessonReservations" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LessonReservationsID instead. It exists only for internal usage by the builders.
func (m *LessonReservationPreferredDateMutation) LessonReservationsIDs() (ids []int) {
	if id := m.lessonReservations; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLessonReservations resets all changes to the "lessonReservations" edge.
func (m *LessonReservationPreferredDateMutation) ResetLessonReservations() {
	m.lessonReservations = nil
	m.clearedlessonReservations = false
}

// Where appends a list predicates to the LessonReservationPreferredDateMutation builder.
func (m *LessonReservationPreferredDateMutation) Where(ps ...predicate.LessonReservationPreferredDate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonReservationPreferredDateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonReservationPreferredDateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LessonReservationPreferredDate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonReservationPreferredDateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonReservationPreferredDateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LessonReservationPreferredDate).
func (m *LessonReservationPreferredDateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonReservationPreferredDateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, lessonreservationpreferreddate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lessonreservationpreferreddate.FieldUpdatedAt)
	}
	if m.lessonReservations != nil {
		fields = append(fields, lessonreservationpreferreddate.FieldLessonReservationID)
	}
	if m.priority != nil {
		fields = append(fields, lessonreservationpreferreddate.FieldPriority)
	}
	if m.date != nil {
		fields = append(fields, lessonreservationpreferreddate.FieldDate)
	}
	if m.start_time != nil {
		fields = append(fields, lessonreservationpreferreddate.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, lessonreservationpreferreddate.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonReservationPreferredDateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lessonreservationpreferreddate.FieldCreatedAt:
		return m.CreatedAt()
	case lessonreservationpreferreddate.FieldUpdatedAt:
		return m.UpdatedAt()
	case lessonreservationpreferreddate.FieldLessonReservationID:
		return m.LessonReservationID()
	case lessonreservationpreferreddate.FieldPriority:
		return m.Priority()
	case lessonreservationpreferreddate.FieldDate:
		return m.Date()
	case lessonreservationpreferreddate.FieldStartTime:
		return m.StartTime()
	case lessonreservationpreferreddate.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonReservationPreferredDateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lessonreservationpreferreddate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lessonreservationpreferreddate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lessonreservationpreferreddate.FieldLessonReservationID:
		return m.OldLessonReservationID(ctx)
	case lessonreservationpreferreddate.FieldPriority:
		return m.OldPriority(ctx)
	case lessonreservationpreferreddate.FieldDate:
		return m.OldDate(ctx)
	case lessonreservationpreferreddate.FieldStartTime:
		return m.OldStartTime(ctx)
	case lessonreservationpreferreddate.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown LessonReservationPreferredDate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonReservationPreferredDateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lessonreservationpreferreddate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lessonreservationpreferreddate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lessonreservationpreferreddate.FieldLessonReservationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonReservationID(v)
		return nil
	case lessonreservationpreferreddate.FieldPriority:
		v, ok := value.(lessonreservationpreferreddate.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case lessonreservationpreferreddate.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case lessonreservationpreferreddate.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case lessonreservationpreferreddate.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown LessonReservationPreferredDate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonReservationPreferredDateMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonReservationPreferredDateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonReservationPreferredDateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LessonReservationPreferredDate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonReservationPreferredDateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonReservationPreferredDateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonReservationPreferredDateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LessonReservationPreferredDate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonReservationPreferredDateMutation) ResetField(name string) error {
	switch name {
	case lessonreservationpreferreddate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lessonreservationpreferreddate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lessonreservationpreferreddate.FieldLessonReservationID:
		m.ResetLessonReservationID()
		return nil
	case lessonreservationpreferreddate.FieldPriority:
		m.ResetPriority()
		return nil
	case lessonreservationpreferreddate.FieldDate:
		m.ResetDate()
		return nil
	case lessonreservationpreferreddate.FieldStartTime:
		m.ResetStartTime()
		return nil
	case lessonreservationpreferreddate.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown LessonReservationPreferredDate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonReservationPreferredDateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lessonReservations != nil {
		edges = append(edges, lessonreservationpreferreddate.EdgeLessonReservations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonReservationPreferredDateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lessonreservationpreferreddate.EdgeLessonReservations:
		if id := m.lessonReservations; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonReservationPreferredDateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonReservationPreferredDateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonReservationPreferredDateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlessonReservations {
		edges = append(edges, lessonreservationpreferreddate.EdgeLessonReservations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonReservationPreferredDateMutation) EdgeCleared(name string) bool {
	switch name {
	case lessonreservationpreferreddate.EdgeLessonReservations:
		return m.clearedlessonReservations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonReservationPreferredDateMutation) ClearEdge(name string) error {
	switch name {
	case lessonreservationpreferreddate.EdgeLessonReservations:
		m.ClearLessonReservations()
		return nil
	}
	return fmt.Errorf("unknown LessonReservationPreferredDate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonReservationPreferredDateMutation) ResetEdge(name string) error {
	switch name {
	case lessonreservationpreferreddate.EdgeLessonReservations:
		m.ResetLessonReservations()
		return nil
	}
	return fmt.Errorf("unknown LessonReservationPreferredDate edge %s", name)
}

// LessonScheduleMutation represents an operation that mutates the LessonSchedule nodes in the graph.
type LessonScheduleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	updated_at                  *time.Time
	title                       *string
	description                 *string
	location                    *string
	lesson_type                 *lessonschedule.LessonType
	annual_max_executions       *int
	addannual_max_executions    *int
	start_date                  *time.Time
	end_date                    *time.Time
	start_time                  *time.Time
	end_time                    *time.Time
	clearedFields               map[string]struct{}
	plan                        *int
	clearedplan                 bool
	grades                      map[int]struct{}
	removedgrades               map[int]struct{}
	clearedgrades               bool
	subjects                    map[int]struct{}
	removedsubjects             map[int]struct{}
	clearedsubjects             bool
	education_categories        map[int]struct{}
	removededucation_categories map[int]struct{}
	clearededucation_categories bool
	lesson_reservations         map[int]struct{}
	removedlesson_reservations  map[int]struct{}
	clearedlesson_reservations  bool
	done                        bool
	oldValue                    func(context.Context) (*LessonSchedule, error)
	predicates                  []predicate.LessonSchedule
}

var _ ent.Mutation = (*LessonScheduleMutation)(nil)

// lessonscheduleOption allows management of the mutation configuration using functional options.
type lessonscheduleOption func(*LessonScheduleMutation)

// newLessonScheduleMutation creates new mutation for the LessonSchedule entity.
func newLessonScheduleMutation(c config, op Op, opts ...lessonscheduleOption) *LessonScheduleMutation {
	m := &LessonScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeLessonSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLessonScheduleID sets the ID field of the mutation.
func withLessonScheduleID(id int) lessonscheduleOption {
	return func(m *LessonScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *LessonSchedule
		)
		m.oldValue = func(ctx context.Context) (*LessonSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LessonSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLessonSchedule sets the old LessonSchedule of the mutation.
func withLessonSchedule(node *LessonSchedule) lessonscheduleOption {
	return func(m *LessonScheduleMutation) {
		m.oldValue = func(context.Context) (*LessonSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LessonScheduleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LessonScheduleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LessonSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LessonScheduleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LessonScheduleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LessonScheduleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LessonScheduleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LessonScheduleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LessonScheduleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLessonPlanID sets the "lesson_plan_id" field.
func (m *LessonScheduleMutation) SetLessonPlanID(i int) {
	m.plan = &i
}

// LessonPlanID returns the value of the "lesson_plan_id" field in the mutation.
func (m *LessonScheduleMutation) LessonPlanID() (r int, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonPlanID returns the old "lesson_plan_id" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldLessonPlanID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonPlanID: %w", err)
	}
	return oldValue.LessonPlanID, nil
}

// ResetLessonPlanID resets all changes to the "lesson_plan_id" field.
func (m *LessonScheduleMutation) ResetLessonPlanID() {
	m.plan = nil
}

// SetTitle sets the "title" field.
func (m *LessonScheduleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *LessonScheduleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *LessonScheduleMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *LessonScheduleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LessonScheduleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LessonScheduleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[lessonschedule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LessonScheduleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[lessonschedule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LessonScheduleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, lessonschedule.FieldDescription)
}

// SetLocation sets the "location" field.
func (m *LessonScheduleMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *LessonScheduleMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *LessonScheduleMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[lessonschedule.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *LessonScheduleMutation) LocationCleared() bool {
	_, ok := m.clearedFields[lessonschedule.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *LessonScheduleMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, lessonschedule.FieldLocation)
}

// SetLessonType sets the "lesson_type" field.
func (m *LessonScheduleMutation) SetLessonType(lt lessonschedule.LessonType) {
	m.lesson_type = &lt
}

// LessonType returns the value of the "lesson_type" field in the mutation.
func (m *LessonScheduleMutation) LessonType() (r lessonschedule.LessonType, exists bool) {
	v := m.lesson_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonType returns the old "lesson_type" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldLessonType(ctx context.Context) (v lessonschedule.LessonType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonType: %w", err)
	}
	return oldValue.LessonType, nil
}

// ResetLessonType resets all changes to the "lesson_type" field.
func (m *LessonScheduleMutation) ResetLessonType() {
	m.lesson_type = nil
}

// SetAnnualMaxExecutions sets the "annual_max_executions" field.
func (m *LessonScheduleMutation) SetAnnualMaxExecutions(i int) {
	m.annual_max_executions = &i
	m.addannual_max_executions = nil
}

// AnnualMaxExecutions returns the value of the "annual_max_executions" field in the mutation.
func (m *LessonScheduleMutation) AnnualMaxExecutions() (r int, exists bool) {
	v := m.annual_max_executions
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnualMaxExecutions returns the old "annual_max_executions" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldAnnualMaxExecutions(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnualMaxExecutions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnualMaxExecutions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnualMaxExecutions: %w", err)
	}
	return oldValue.AnnualMaxExecutions, nil
}

// AddAnnualMaxExecutions adds i to the "annual_max_executions" field.
func (m *LessonScheduleMutation) AddAnnualMaxExecutions(i int) {
	if m.addannual_max_executions != nil {
		*m.addannual_max_executions += i
	} else {
		m.addannual_max_executions = &i
	}
}

// AddedAnnualMaxExecutions returns the value that was added to the "annual_max_executions" field in this mutation.
func (m *LessonScheduleMutation) AddedAnnualMaxExecutions() (r int, exists bool) {
	v := m.addannual_max_executions
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnnualMaxExecutions resets all changes to the "annual_max_executions" field.
func (m *LessonScheduleMutation) ResetAnnualMaxExecutions() {
	m.annual_max_executions = nil
	m.addannual_max_executions = nil
}

// SetStartDate sets the "start_date" field.
func (m *LessonScheduleMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *LessonScheduleMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *LessonScheduleMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *LessonScheduleMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *LessonScheduleMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *LessonScheduleMutation) ResetEndDate() {
	m.end_date = nil
}

// SetStartTime sets the "start_time" field.
func (m *LessonScheduleMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *LessonScheduleMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *LessonScheduleMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *LessonScheduleMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *LessonScheduleMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the LessonSchedule entity.
// If the LessonSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonScheduleMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *LessonScheduleMutation) ResetEndTime() {
	m.end_time = nil
}

// SetPlanID sets the "plan" edge to the LessonPlan entity by id.
func (m *LessonScheduleMutation) SetPlanID(id int) {
	m.plan = &id
}

// ClearPlan clears the "plan" edge to the LessonPlan entity.
func (m *LessonScheduleMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[lessonschedule.FieldLessonPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the LessonPlan entity was cleared.
func (m *LessonScheduleMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanID returns the "plan" edge ID in the mutation.
func (m *LessonScheduleMutation) PlanID() (id int, exists bool) {
	if m.plan != nil {
		return *m.plan, true
	}
	return
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *LessonScheduleMutation) PlanIDs() (ids []int) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *LessonScheduleMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// AddGradeIDs adds the "grades" edge to the Grade entity by ids.
func (m *LessonScheduleMutation) AddGradeIDs(ids ...int) {
	if m.grades == nil {
		m.grades = make(map[int]struct{})
	}
	for i := range ids {
		m.grades[ids[i]] = struct{}{}
	}
}

// ClearGrades clears the "grades" edge to the Grade entity.
func (m *LessonScheduleMutation) ClearGrades() {
	m.clearedgrades = true
}

// GradesCleared reports if the "grades" edge to the Grade entity was cleared.
func (m *LessonScheduleMutation) GradesCleared() bool {
	return m.clearedgrades
}

// RemoveGradeIDs removes the "grades" edge to the Grade entity by IDs.
func (m *LessonScheduleMutation) RemoveGradeIDs(ids ...int) {
	if m.removedgrades == nil {
		m.removedgrades = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grades, ids[i])
		m.removedgrades[ids[i]] = struct{}{}
	}
}

// RemovedGrades returns the removed IDs of the "grades" edge to the Grade entity.
func (m *LessonScheduleMutation) RemovedGradesIDs() (ids []int) {
	for id := range m.removedgrades {
		ids = append(ids, id)
	}
	return
}

// GradesIDs returns the "grades" edge IDs in the mutation.
func (m *LessonScheduleMutation) GradesIDs() (ids []int) {
	for id := range m.grades {
		ids = append(ids, id)
	}
	return
}

// ResetGrades resets all changes to the "grades" edge.
func (m *LessonScheduleMutation) ResetGrades() {
	m.grades = nil
	m.clearedgrades = false
	m.removedgrades = nil
}

// AddSubjectIDs adds the "subjects" edge to the Subject entity by ids.
func (m *LessonScheduleMutation) AddSubjectIDs(ids ...int) {
	if m.subjects == nil {
		m.subjects = make(map[int]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the Subject entity.
func (m *LessonScheduleMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the Subject entity was cleared.
func (m *LessonScheduleMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the Subject entity by IDs.
func (m *LessonScheduleMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the Subject entity.
func (m *LessonScheduleMutation) RemovedSubjectsIDs() (ids []int) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *LessonScheduleMutation) SubjectsIDs() (ids []int) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *LessonScheduleMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// AddEducationCategoryIDs adds the "education_categories" edge to the EducationCategory entity by ids.
func (m *LessonScheduleMutation) AddEducationCategoryIDs(ids ...int) {
	if m.education_categories == nil {
		m.education_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.education_categories[ids[i]] = struct{}{}
	}
}

// ClearEducationCategories clears the "education_categories" edge to the EducationCategory entity.
func (m *LessonScheduleMutation) ClearEducationCategories() {
	m.clearededucation_categories = true
}

// EducationCategoriesCleared reports if the "education_categories" edge to the EducationCategory entity was cleared.
func (m *LessonScheduleMutation) EducationCategoriesCleared() bool {
	return m.clearededucation_categories
}

// RemoveEducationCategoryIDs removes the "education_categories" edge to the EducationCategory entity by IDs.
func (m *LessonScheduleMutation) RemoveEducationCategoryIDs(ids ...int) {
	if m.removededucation_categories == nil {
		m.removededucation_categories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.education_categories, ids[i])
		m.removededucation_categories[ids[i]] = struct{}{}
	}
}

// RemovedEducationCategories returns the removed IDs of the "education_categories" edge to the EducationCategory entity.
func (m *LessonScheduleMutation) RemovedEducationCategoriesIDs() (ids []int) {
	for id := range m.removededucation_categories {
		ids = append(ids, id)
	}
	return
}

// EducationCategoriesIDs returns the "education_categories" edge IDs in the mutation.
func (m *LessonScheduleMutation) EducationCategoriesIDs() (ids []int) {
	for id := range m.education_categories {
		ids = append(ids, id)
	}
	return
}

// ResetEducationCategories resets all changes to the "education_categories" edge.
func (m *LessonScheduleMutation) ResetEducationCategories() {
	m.education_categories = nil
	m.clearededucation_categories = false
	m.removededucation_categories = nil
}

// AddLessonReservationIDs adds the "lesson_reservations" edge to the LessonReservation entity by ids.
func (m *LessonScheduleMutation) AddLessonReservationIDs(ids ...int) {
	if m.lesson_reservations == nil {
		m.lesson_reservations = make(map[int]struct{})
	}
	for i := range ids {
		m.lesson_reservations[ids[i]] = struct{}{}
	}
}

// ClearLessonReservations clears the "lesson_reservations" edge to the LessonReservation entity.
func (m *LessonScheduleMutation) ClearLessonReservations() {
	m.clearedlesson_reservations = true
}

// LessonReservationsCleared reports if the "lesson_reservations" edge to the LessonReservation entity was cleared.
func (m *LessonScheduleMutation) LessonReservationsCleared() bool {
	return m.clearedlesson_reservations
}

// RemoveLessonReservationIDs removes the "lesson_reservations" edge to the LessonReservation entity by IDs.
func (m *LessonScheduleMutation) RemoveLessonReservationIDs(ids ...int) {
	if m.removedlesson_reservations == nil {
		m.removedlesson_reservations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lesson_reservations, ids[i])
		m.removedlesson_reservations[ids[i]] = struct{}{}
	}
}

// RemovedLessonReservations returns the removed IDs of the "lesson_reservations" edge to the LessonReservation entity.
func (m *LessonScheduleMutation) RemovedLessonReservationsIDs() (ids []int) {
	for id := range m.removedlesson_reservations {
		ids = append(ids, id)
	}
	return
}

// LessonReservationsIDs returns the "lesson_reservations" edge IDs in the mutation.
func (m *LessonScheduleMutation) LessonReservationsIDs() (ids []int) {
	for id := range m.lesson_reservations {
		ids = append(ids, id)
	}
	return
}

// ResetLessonReservations resets all changes to the "lesson_reservations" edge.
func (m *LessonScheduleMutation) ResetLessonReservations() {
	m.lesson_reservations = nil
	m.clearedlesson_reservations = false
	m.removedlesson_reservations = nil
}

// Where appends a list predicates to the LessonScheduleMutation builder.
func (m *LessonScheduleMutation) Where(ps ...predicate.LessonSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LessonSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LessonSchedule).
func (m *LessonScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonScheduleMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, lessonschedule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lessonschedule.FieldUpdatedAt)
	}
	if m.plan != nil {
		fields = append(fields, lessonschedule.FieldLessonPlanID)
	}
	if m.title != nil {
		fields = append(fields, lessonschedule.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, lessonschedule.FieldDescription)
	}
	if m.location != nil {
		fields = append(fields, lessonschedule.FieldLocation)
	}
	if m.lesson_type != nil {
		fields = append(fields, lessonschedule.FieldLessonType)
	}
	if m.annual_max_executions != nil {
		fields = append(fields, lessonschedule.FieldAnnualMaxExecutions)
	}
	if m.start_date != nil {
		fields = append(fields, lessonschedule.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, lessonschedule.FieldEndDate)
	}
	if m.start_time != nil {
		fields = append(fields, lessonschedule.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, lessonschedule.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lessonschedule.FieldCreatedAt:
		return m.CreatedAt()
	case lessonschedule.FieldUpdatedAt:
		return m.UpdatedAt()
	case lessonschedule.FieldLessonPlanID:
		return m.LessonPlanID()
	case lessonschedule.FieldTitle:
		return m.Title()
	case lessonschedule.FieldDescription:
		return m.Description()
	case lessonschedule.FieldLocation:
		return m.Location()
	case lessonschedule.FieldLessonType:
		return m.LessonType()
	case lessonschedule.FieldAnnualMaxExecutions:
		return m.AnnualMaxExecutions()
	case lessonschedule.FieldStartDate:
		return m.StartDate()
	case lessonschedule.FieldEndDate:
		return m.EndDate()
	case lessonschedule.FieldStartTime:
		return m.StartTime()
	case lessonschedule.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lessonschedule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lessonschedule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case lessonschedule.FieldLessonPlanID:
		return m.OldLessonPlanID(ctx)
	case lessonschedule.FieldTitle:
		return m.OldTitle(ctx)
	case lessonschedule.FieldDescription:
		return m.OldDescription(ctx)
	case lessonschedule.FieldLocation:
		return m.OldLocation(ctx)
	case lessonschedule.FieldLessonType:
		return m.OldLessonType(ctx)
	case lessonschedule.FieldAnnualMaxExecutions:
		return m.OldAnnualMaxExecutions(ctx)
	case lessonschedule.FieldStartDate:
		return m.OldStartDate(ctx)
	case lessonschedule.FieldEndDate:
		return m.OldEndDate(ctx)
	case lessonschedule.FieldStartTime:
		return m.OldStartTime(ctx)
	case lessonschedule.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown LessonSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lessonschedule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lessonschedule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case lessonschedule.FieldLessonPlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonPlanID(v)
		return nil
	case lessonschedule.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case lessonschedule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case lessonschedule.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case lessonschedule.FieldLessonType:
		v, ok := value.(lessonschedule.LessonType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonType(v)
		return nil
	case lessonschedule.FieldAnnualMaxExecutions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnualMaxExecutions(v)
		return nil
	case lessonschedule.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case lessonschedule.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case lessonschedule.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case lessonschedule.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown LessonSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addannual_max_executions != nil {
		fields = append(fields, lessonschedule.FieldAnnualMaxExecutions)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lessonschedule.FieldAnnualMaxExecutions:
		return m.AddedAnnualMaxExecutions()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lessonschedule.FieldAnnualMaxExecutions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnnualMaxExecutions(v)
		return nil
	}
	return fmt.Errorf("unknown LessonSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lessonschedule.FieldDescription) {
		fields = append(fields, lessonschedule.FieldDescription)
	}
	if m.FieldCleared(lessonschedule.FieldLocation) {
		fields = append(fields, lessonschedule.FieldLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonScheduleMutation) ClearField(name string) error {
	switch name {
	case lessonschedule.FieldDescription:
		m.ClearDescription()
		return nil
	case lessonschedule.FieldLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown LessonSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonScheduleMutation) ResetField(name string) error {
	switch name {
	case lessonschedule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lessonschedule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case lessonschedule.FieldLessonPlanID:
		m.ResetLessonPlanID()
		return nil
	case lessonschedule.FieldTitle:
		m.ResetTitle()
		return nil
	case lessonschedule.FieldDescription:
		m.ResetDescription()
		return nil
	case lessonschedule.FieldLocation:
		m.ResetLocation()
		return nil
	case lessonschedule.FieldLessonType:
		m.ResetLessonType()
		return nil
	case lessonschedule.FieldAnnualMaxExecutions:
		m.ResetAnnualMaxExecutions()
		return nil
	case lessonschedule.FieldStartDate:
		m.ResetStartDate()
		return nil
	case lessonschedule.FieldEndDate:
		m.ResetEndDate()
		return nil
	case lessonschedule.FieldStartTime:
		m.ResetStartTime()
		return nil
	case lessonschedule.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown LessonSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.plan != nil {
		edges = append(edges, lessonschedule.EdgePlan)
	}
	if m.grades != nil {
		edges = append(edges, lessonschedule.EdgeGrades)
	}
	if m.subjects != nil {
		edges = append(edges, lessonschedule.EdgeSubjects)
	}
	if m.education_categories != nil {
		edges = append(edges, lessonschedule.EdgeEducationCategories)
	}
	if m.lesson_reservations != nil {
		edges = append(edges, lessonschedule.EdgeLessonReservations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lessonschedule.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case lessonschedule.EdgeGrades:
		ids := make([]ent.Value, 0, len(m.grades))
		for id := range m.grades {
			ids = append(ids, id)
		}
		return ids
	case lessonschedule.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	case lessonschedule.EdgeEducationCategories:
		ids := make([]ent.Value, 0, len(m.education_categories))
		for id := range m.education_categories {
			ids = append(ids, id)
		}
		return ids
	case lessonschedule.EdgeLessonReservations:
		ids := make([]ent.Value, 0, len(m.lesson_reservations))
		for id := range m.lesson_reservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedgrades != nil {
		edges = append(edges, lessonschedule.EdgeGrades)
	}
	if m.removedsubjects != nil {
		edges = append(edges, lessonschedule.EdgeSubjects)
	}
	if m.removededucation_categories != nil {
		edges = append(edges, lessonschedule.EdgeEducationCategories)
	}
	if m.removedlesson_reservations != nil {
		edges = append(edges, lessonschedule.EdgeLessonReservations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lessonschedule.EdgeGrades:
		ids := make([]ent.Value, 0, len(m.removedgrades))
		for id := range m.removedgrades {
			ids = append(ids, id)
		}
		return ids
	case lessonschedule.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	case lessonschedule.EdgeEducationCategories:
		ids := make([]ent.Value, 0, len(m.removededucation_categories))
		for id := range m.removededucation_categories {
			ids = append(ids, id)
		}
		return ids
	case lessonschedule.EdgeLessonReservations:
		ids := make([]ent.Value, 0, len(m.removedlesson_reservations))
		for id := range m.removedlesson_reservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedplan {
		edges = append(edges, lessonschedule.EdgePlan)
	}
	if m.clearedgrades {
		edges = append(edges, lessonschedule.EdgeGrades)
	}
	if m.clearedsubjects {
		edges = append(edges, lessonschedule.EdgeSubjects)
	}
	if m.clearededucation_categories {
		edges = append(edges, lessonschedule.EdgeEducationCategories)
	}
	if m.clearedlesson_reservations {
		edges = append(edges, lessonschedule.EdgeLessonReservations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case lessonschedule.EdgePlan:
		return m.clearedplan
	case lessonschedule.EdgeGrades:
		return m.clearedgrades
	case lessonschedule.EdgeSubjects:
		return m.clearedsubjects
	case lessonschedule.EdgeEducationCategories:
		return m.clearededucation_categories
	case lessonschedule.EdgeLessonReservations:
		return m.clearedlesson_reservations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonScheduleMutation) ClearEdge(name string) error {
	switch name {
	case lessonschedule.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown LessonSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonScheduleMutation) ResetEdge(name string) error {
	switch name {
	case lessonschedule.EdgePlan:
		m.ResetPlan()
		return nil
	case lessonschedule.EdgeGrades:
		m.ResetGrades()
		return nil
	case lessonschedule.EdgeSubjects:
		m.ResetSubjects()
		return nil
	case lessonschedule.EdgeEducationCategories:
		m.ResetEducationCategories()
		return nil
	case lessonschedule.EdgeLessonReservations:
		m.ResetLessonReservations()
		return nil
	}
	return fmt.Errorf("unknown LessonSchedule edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	price         *int
	addprice      *int
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Product, error)
	predicates    []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *ProductMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldPrice:
		return m.Price()
	case product.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Product edge %s", name)
}

// SchoolMutation represents an operation that mutates the School nodes in the graph.
type SchoolMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	created_at                 *time.Time
	updated_at                 *time.Time
	school_type                *school.SchoolType
	name                       *string
	email                      *string
	phone_number               *string
	prefecture                 *int
	addprefecture              *int
	city                       *string
	street                     *string
	post_code                  *string
	url                        *string
	clearedFields              map[string]struct{}
	teachers                   map[int]struct{}
	removedteachers            map[int]struct{}
	clearedteachers            bool
	lesson_reservations        map[int]struct{}
	removedlesson_reservations map[int]struct{}
	clearedlesson_reservations bool
	done                       bool
	oldValue                   func(context.Context) (*School, error)
	predicates                 []predicate.School
}

var _ ent.Mutation = (*SchoolMutation)(nil)

// schoolOption allows management of the mutation configuration using functional options.
type schoolOption func(*SchoolMutation)

// newSchoolMutation creates new mutation for the School entity.
func newSchoolMutation(c config, op Op, opts ...schoolOption) *SchoolMutation {
	m := &SchoolMutation{
		config:        c,
		op:            op,
		typ:           TypeSchool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchoolID sets the ID field of the mutation.
func withSchoolID(id int) schoolOption {
	return func(m *SchoolMutation) {
		var (
			err   error
			once  sync.Once
			value *School
		)
		m.oldValue = func(ctx context.Context) (*School, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().School.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchool sets the old School of the mutation.
func withSchool(node *School) schoolOption {
	return func(m *SchoolMutation) {
		m.oldValue = func(context.Context) (*School, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchoolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchoolMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().School.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SchoolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SchoolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SchoolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SchoolMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SchoolMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SchoolMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSchoolType sets the "school_type" field.
func (m *SchoolMutation) SetSchoolType(st school.SchoolType) {
	m.school_type = &st
}

// SchoolType returns the value of the "school_type" field in the mutation.
func (m *SchoolMutation) SchoolType() (r school.SchoolType, exists bool) {
	v := m.school_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSchoolType returns the old "school_type" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldSchoolType(ctx context.Context) (v school.SchoolType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchoolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchoolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchoolType: %w", err)
	}
	return oldValue.SchoolType, nil
}

// ResetSchoolType resets all changes to the "school_type" field.
func (m *SchoolMutation) ResetSchoolType() {
	m.school_type = nil
}

// SetName sets the "name" field.
func (m *SchoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchoolMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *SchoolMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SchoolMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *SchoolMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[school.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *SchoolMutation) EmailCleared() bool {
	_, ok := m.clearedFields[school.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *SchoolMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, school.FieldEmail)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *SchoolMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *SchoolMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *SchoolMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetPrefecture sets the "prefecture" field.
func (m *SchoolMutation) SetPrefecture(i int) {
	m.prefecture = &i
	m.addprefecture = nil
}

// Prefecture returns the value of the "prefecture" field in the mutation.
func (m *SchoolMutation) Prefecture() (r int, exists bool) {
	v := m.prefecture
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefecture returns the old "prefecture" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldPrefecture(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefecture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefecture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefecture: %w", err)
	}
	return oldValue.Prefecture, nil
}

// AddPrefecture adds i to the "prefecture" field.
func (m *SchoolMutation) AddPrefecture(i int) {
	if m.addprefecture != nil {
		*m.addprefecture += i
	} else {
		m.addprefecture = &i
	}
}

// AddedPrefecture returns the value that was added to the "prefecture" field in this mutation.
func (m *SchoolMutation) AddedPrefecture() (r int, exists bool) {
	v := m.addprefecture
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrefecture resets all changes to the "prefecture" field.
func (m *SchoolMutation) ResetPrefecture() {
	m.prefecture = nil
	m.addprefecture = nil
}

// SetCity sets the "city" field.
func (m *SchoolMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *SchoolMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *SchoolMutation) ResetCity() {
	m.city = nil
}

// SetStreet sets the "street" field.
func (m *SchoolMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the value of the "street" field in the mutation.
func (m *SchoolMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "street" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "street" field.
func (m *SchoolMutation) ClearStreet() {
	m.street = nil
	m.clearedFields[school.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "street" field was cleared in this mutation.
func (m *SchoolMutation) StreetCleared() bool {
	_, ok := m.clearedFields[school.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "street" field.
func (m *SchoolMutation) ResetStreet() {
	m.street = nil
	delete(m.clearedFields, school.FieldStreet)
}

// SetPostCode sets the "post_code" field.
func (m *SchoolMutation) SetPostCode(s string) {
	m.post_code = &s
}

// PostCode returns the value of the "post_code" field in the mutation.
func (m *SchoolMutation) PostCode() (r string, exists bool) {
	v := m.post_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCode returns the old "post_code" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldPostCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCode: %w", err)
	}
	return oldValue.PostCode, nil
}

// ResetPostCode resets all changes to the "post_code" field.
func (m *SchoolMutation) ResetPostCode() {
	m.post_code = nil
}

// SetURL sets the "url" field.
func (m *SchoolMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SchoolMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *SchoolMutation) ClearURL() {
	m.url = nil
	m.clearedFields[school.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *SchoolMutation) URLCleared() bool {
	_, ok := m.clearedFields[school.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *SchoolMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, school.FieldURL)
}

// AddTeacherIDs adds the "teachers" edge to the User entity by ids.
func (m *SchoolMutation) AddTeacherIDs(ids ...int) {
	if m.teachers == nil {
		m.teachers = make(map[int]struct{})
	}
	for i := range ids {
		m.teachers[ids[i]] = struct{}{}
	}
}

// ClearTeachers clears the "teachers" edge to the User entity.
func (m *SchoolMutation) ClearTeachers() {
	m.clearedteachers = true
}

// TeachersCleared reports if the "teachers" edge to the User entity was cleared.
func (m *SchoolMutation) TeachersCleared() bool {
	return m.clearedteachers
}

// RemoveTeacherIDs removes the "teachers" edge to the User entity by IDs.
func (m *SchoolMutation) RemoveTeacherIDs(ids ...int) {
	if m.removedteachers == nil {
		m.removedteachers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teachers, ids[i])
		m.removedteachers[ids[i]] = struct{}{}
	}
}

// RemovedTeachers returns the removed IDs of the "teachers" edge to the User entity.
func (m *SchoolMutation) RemovedTeachersIDs() (ids []int) {
	for id := range m.removedteachers {
		ids = append(ids, id)
	}
	return
}

// TeachersIDs returns the "teachers" edge IDs in the mutation.
func (m *SchoolMutation) TeachersIDs() (ids []int) {
	for id := range m.teachers {
		ids = append(ids, id)
	}
	return
}

// ResetTeachers resets all changes to the "teachers" edge.
func (m *SchoolMutation) ResetTeachers() {
	m.teachers = nil
	m.clearedteachers = false
	m.removedteachers = nil
}

// AddLessonReservationIDs adds the "lesson_reservations" edge to the LessonReservation entity by ids.
func (m *SchoolMutation) AddLessonReservationIDs(ids ...int) {
	if m.lesson_reservations == nil {
		m.lesson_reservations = make(map[int]struct{})
	}
	for i := range ids {
		m.lesson_reservations[ids[i]] = struct{}{}
	}
}

// ClearLessonReservations clears the "lesson_reservations" edge to the LessonReservation entity.
func (m *SchoolMutation) ClearLessonReservations() {
	m.clearedlesson_reservations = true
}

// LessonReservationsCleared reports if the "lesson_reservations" edge to the LessonReservation entity was cleared.
func (m *SchoolMutation) LessonReservationsCleared() bool {
	return m.clearedlesson_reservations
}

// RemoveLessonReservationIDs removes the "lesson_reservations" edge to the LessonReservation entity by IDs.
func (m *SchoolMutation) RemoveLessonReservationIDs(ids ...int) {
	if m.removedlesson_reservations == nil {
		m.removedlesson_reservations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lesson_reservations, ids[i])
		m.removedlesson_reservations[ids[i]] = struct{}{}
	}
}

// RemovedLessonReservations returns the removed IDs of the "lesson_reservations" edge to the LessonReservation entity.
func (m *SchoolMutation) RemovedLessonReservationsIDs() (ids []int) {
	for id := range m.removedlesson_reservations {
		ids = append(ids, id)
	}
	return
}

// LessonReservationsIDs returns the "lesson_reservations" edge IDs in the mutation.
func (m *SchoolMutation) LessonReservationsIDs() (ids []int) {
	for id := range m.lesson_reservations {
		ids = append(ids, id)
	}
	return
}

// ResetLessonReservations resets all changes to the "lesson_reservations" edge.
func (m *SchoolMutation) ResetLessonReservations() {
	m.lesson_reservations = nil
	m.clearedlesson_reservations = false
	m.removedlesson_reservations = nil
}

// Where appends a list predicates to the SchoolMutation builder.
func (m *SchoolMutation) Where(ps ...predicate.School) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchoolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchoolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.School, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchoolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchoolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (School).
func (m *SchoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchoolMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, school.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, school.FieldUpdatedAt)
	}
	if m.school_type != nil {
		fields = append(fields, school.FieldSchoolType)
	}
	if m.name != nil {
		fields = append(fields, school.FieldName)
	}
	if m.email != nil {
		fields = append(fields, school.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, school.FieldPhoneNumber)
	}
	if m.prefecture != nil {
		fields = append(fields, school.FieldPrefecture)
	}
	if m.city != nil {
		fields = append(fields, school.FieldCity)
	}
	if m.street != nil {
		fields = append(fields, school.FieldStreet)
	}
	if m.post_code != nil {
		fields = append(fields, school.FieldPostCode)
	}
	if m.url != nil {
		fields = append(fields, school.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case school.FieldCreatedAt:
		return m.CreatedAt()
	case school.FieldUpdatedAt:
		return m.UpdatedAt()
	case school.FieldSchoolType:
		return m.SchoolType()
	case school.FieldName:
		return m.Name()
	case school.FieldEmail:
		return m.Email()
	case school.FieldPhoneNumber:
		return m.PhoneNumber()
	case school.FieldPrefecture:
		return m.Prefecture()
	case school.FieldCity:
		return m.City()
	case school.FieldStreet:
		return m.Street()
	case school.FieldPostCode:
		return m.PostCode()
	case school.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case school.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case school.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case school.FieldSchoolType:
		return m.OldSchoolType(ctx)
	case school.FieldName:
		return m.OldName(ctx)
	case school.FieldEmail:
		return m.OldEmail(ctx)
	case school.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case school.FieldPrefecture:
		return m.OldPrefecture(ctx)
	case school.FieldCity:
		return m.OldCity(ctx)
	case school.FieldStreet:
		return m.OldStreet(ctx)
	case school.FieldPostCode:
		return m.OldPostCode(ctx)
	case school.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown School field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case school.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case school.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case school.FieldSchoolType:
		v, ok := value.(school.SchoolType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchoolType(v)
		return nil
	case school.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case school.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case school.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case school.FieldPrefecture:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefecture(v)
		return nil
	case school.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case school.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case school.FieldPostCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCode(v)
		return nil
	case school.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchoolMutation) AddedFields() []string {
	var fields []string
	if m.addprefecture != nil {
		fields = append(fields, school.FieldPrefecture)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchoolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case school.FieldPrefecture:
		return m.AddedPrefecture()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case school.FieldPrefecture:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrefecture(v)
		return nil
	}
	return fmt.Errorf("unknown School numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchoolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(school.FieldEmail) {
		fields = append(fields, school.FieldEmail)
	}
	if m.FieldCleared(school.FieldStreet) {
		fields = append(fields, school.FieldStreet)
	}
	if m.FieldCleared(school.FieldURL) {
		fields = append(fields, school.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchoolMutation) ClearField(name string) error {
	switch name {
	case school.FieldEmail:
		m.ClearEmail()
		return nil
	case school.FieldStreet:
		m.ClearStreet()
		return nil
	case school.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown School nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchoolMutation) ResetField(name string) error {
	switch name {
	case school.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case school.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case school.FieldSchoolType:
		m.ResetSchoolType()
		return nil
	case school.FieldName:
		m.ResetName()
		return nil
	case school.FieldEmail:
		m.ResetEmail()
		return nil
	case school.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case school.FieldPrefecture:
		m.ResetPrefecture()
		return nil
	case school.FieldCity:
		m.ResetCity()
		return nil
	case school.FieldStreet:
		m.ResetStreet()
		return nil
	case school.FieldPostCode:
		m.ResetPostCode()
		return nil
	case school.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.teachers != nil {
		edges = append(edges, school.EdgeTeachers)
	}
	if m.lesson_reservations != nil {
		edges = append(edges, school.EdgeLessonReservations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeTeachers:
		ids := make([]ent.Value, 0, len(m.teachers))
		for id := range m.teachers {
			ids = append(ids, id)
		}
		return ids
	case school.EdgeLessonReservations:
		ids := make([]ent.Value, 0, len(m.lesson_reservations))
		for id := range m.lesson_reservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedteachers != nil {
		edges = append(edges, school.EdgeTeachers)
	}
	if m.removedlesson_reservations != nil {
		edges = append(edges, school.EdgeLessonReservations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeTeachers:
		ids := make([]ent.Value, 0, len(m.removedteachers))
		for id := range m.removedteachers {
			ids = append(ids, id)
		}
		return ids
	case school.EdgeLessonReservations:
		ids := make([]ent.Value, 0, len(m.removedlesson_reservations))
		for id := range m.removedlesson_reservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteachers {
		edges = append(edges, school.EdgeTeachers)
	}
	if m.clearedlesson_reservations {
		edges = append(edges, school.EdgeLessonReservations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchoolMutation) EdgeCleared(name string) bool {
	switch name {
	case school.EdgeTeachers:
		return m.clearedteachers
	case school.EdgeLessonReservations:
		return m.clearedlesson_reservations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchoolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown School unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchoolMutation) ResetEdge(name string) error {
	switch name {
	case school.EdgeTeachers:
		m.ResetTeachers()
		return nil
	case school.EdgeLessonReservations:
		m.ResetLessonReservations()
		return nil
	}
	return fmt.Errorf("unknown School edge %s", name)
}

// SubjectMutation represents an operation that mutates the Subject nodes in the graph.
type SubjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	code                *string
	clearedFields       map[string]struct{}
	lesson_plans        map[int]struct{}
	removedlesson_plans map[int]struct{}
	clearedlesson_plans bool
	done                bool
	oldValue            func(context.Context) (*Subject, error)
	predicates          []predicate.Subject
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows management of the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for the Subject entity.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the ID field of the mutation.
func withSubjectID(id int) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *SubjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubjectMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *SubjectMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SubjectMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *SubjectMutation) ResetCode() {
	m.code = nil
}

// AddLessonPlanIDs adds the "lesson_plans" edge to the LessonPlan entity by ids.
func (m *SubjectMutation) AddLessonPlanIDs(ids ...int) {
	if m.lesson_plans == nil {
		m.lesson_plans = make(map[int]struct{})
	}
	for i := range ids {
		m.lesson_plans[ids[i]] = struct{}{}
	}
}

// ClearLessonPlans clears the "lesson_plans" edge to the LessonPlan entity.
func (m *SubjectMutation) ClearLessonPlans() {
	m.clearedlesson_plans = true
}

// LessonPlansCleared reports if the "lesson_plans" edge to the LessonPlan entity was cleared.
func (m *SubjectMutation) LessonPlansCleared() bool {
	return m.clearedlesson_plans
}

// RemoveLessonPlanIDs removes the "lesson_plans" edge to the LessonPlan entity by IDs.
func (m *SubjectMutation) RemoveLessonPlanIDs(ids ...int) {
	if m.removedlesson_plans == nil {
		m.removedlesson_plans = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lesson_plans, ids[i])
		m.removedlesson_plans[ids[i]] = struct{}{}
	}
}

// RemovedLessonPlans returns the removed IDs of the "lesson_plans" edge to the LessonPlan entity.
func (m *SubjectMutation) RemovedLessonPlansIDs() (ids []int) {
	for id := range m.removedlesson_plans {
		ids = append(ids, id)
	}
	return
}

// LessonPlansIDs returns the "lesson_plans" edge IDs in the mutation.
func (m *SubjectMutation) LessonPlansIDs() (ids []int) {
	for id := range m.lesson_plans {
		ids = append(ids, id)
	}
	return
}

// ResetLessonPlans resets all changes to the "lesson_plans" edge.
func (m *SubjectMutation) ResetLessonPlans() {
	m.lesson_plans = nil
	m.clearedlesson_plans = false
	m.removedlesson_plans = nil
}

// Where appends a list predicates to the SubjectMutation builder.
func (m *SubjectMutation) Where(ps ...predicate.Subject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, subject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subject.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, subject.FieldName)
	}
	if m.code != nil {
		fields = append(fields, subject.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldCreatedAt:
		return m.CreatedAt()
	case subject.FieldUpdatedAt:
		return m.UpdatedAt()
	case subject.FieldName:
		return m.Name()
	case subject.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subject.FieldName:
		return m.OldName(ctx)
	case subject.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subject.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subject.FieldName:
		m.ResetName()
		return nil
	case subject.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.lesson_plans != nil {
		edges = append(edges, subject.EdgeLessonPlans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeLessonPlans:
		ids := make([]ent.Value, 0, len(m.lesson_plans))
		for id := range m.lesson_plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlesson_plans != nil {
		edges = append(edges, subject.EdgeLessonPlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeLessonPlans:
		ids := make([]ent.Value, 0, len(m.removedlesson_plans))
		for id := range m.removedlesson_plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlesson_plans {
		edges = append(edges, subject.EdgeLessonPlans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	case subject.EdgeLessonPlans:
		return m.clearedlesson_plans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeLessonPlans:
		m.ResetLessonPlans()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// UploadFileMutation represents an operation that mutates the UploadFile nodes in the graph.
type UploadFileMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	photo_key          *string
	user_id            *int
	adduser_id         *int
	clearedFields      map[string]struct{}
	_LessonPlan        *int
	cleared_LessonPlan bool
	done               bool
	oldValue           func(context.Context) (*UploadFile, error)
	predicates         []predicate.UploadFile
}

var _ ent.Mutation = (*UploadFileMutation)(nil)

// uploadfileOption allows management of the mutation configuration using functional options.
type uploadfileOption func(*UploadFileMutation)

// newUploadFileMutation creates new mutation for the UploadFile entity.
func newUploadFileMutation(c config, op Op, opts ...uploadfileOption) *UploadFileMutation {
	m := &UploadFileMutation{
		config:        c,
		op:            op,
		typ:           TypeUploadFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUploadFileID sets the ID field of the mutation.
func withUploadFileID(id int) uploadfileOption {
	return func(m *UploadFileMutation) {
		var (
			err   error
			once  sync.Once
			value *UploadFile
		)
		m.oldValue = func(ctx context.Context) (*UploadFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UploadFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUploadFile sets the old UploadFile of the mutation.
func withUploadFile(node *UploadFile) uploadfileOption {
	return func(m *UploadFileMutation) {
		m.oldValue = func(context.Context) (*UploadFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UploadFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UploadFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UploadFileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UploadFileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UploadFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UploadFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UploadFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UploadFile entity.
// If the UploadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UploadFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UploadFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UploadFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UploadFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UploadFile entity.
// If the UploadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UploadFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UploadFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPhotoKey sets the "photo_key" field.
func (m *UploadFileMutation) SetPhotoKey(s string) {
	m.photo_key = &s
}

// PhotoKey returns the value of the "photo_key" field in the mutation.
func (m *UploadFileMutation) PhotoKey() (r string, exists bool) {
	v := m.photo_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoKey returns the old "photo_key" field's value of the UploadFile entity.
// If the UploadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UploadFileMutation) OldPhotoKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoKey: %w", err)
	}
	return oldValue.PhotoKey, nil
}

// ResetPhotoKey resets all changes to the "photo_key" field.
func (m *UploadFileMutation) ResetPhotoKey() {
	m.photo_key = nil
}

// SetUserID sets the "user_id" field.
func (m *UploadFileMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UploadFileMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UploadFile entity.
// If the UploadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UploadFileMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UploadFileMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UploadFileMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UploadFileMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetLessonPlanID sets the "LessonPlan" edge to the LessonPlan entity by id.
func (m *UploadFileMutation) SetLessonPlanID(id int) {
	m._LessonPlan = &id
}

// ClearLessonPlan clears the "LessonPlan" edge to the LessonPlan entity.
func (m *UploadFileMutation) ClearLessonPlan() {
	m.cleared_LessonPlan = true
}

// LessonPlanCleared reports if the "LessonPlan" edge to the LessonPlan entity was cleared.
func (m *UploadFileMutation) LessonPlanCleared() bool {
	return m.cleared_LessonPlan
}

// LessonPlanID returns the "LessonPlan" edge ID in the mutation.
func (m *UploadFileMutation) LessonPlanID() (id int, exists bool) {
	if m._LessonPlan != nil {
		return *m._LessonPlan, true
	}
	return
}

// LessonPlanIDs returns the "LessonPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LessonPlanID instead. It exists only for internal usage by the builders.
func (m *UploadFileMutation) LessonPlanIDs() (ids []int) {
	if id := m._LessonPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLessonPlan resets all changes to the "LessonPlan" edge.
func (m *UploadFileMutation) ResetLessonPlan() {
	m._LessonPlan = nil
	m.cleared_LessonPlan = false
}

// Where appends a list predicates to the UploadFileMutation builder.
func (m *UploadFileMutation) Where(ps ...predicate.UploadFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UploadFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UploadFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UploadFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UploadFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UploadFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UploadFile).
func (m *UploadFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UploadFileMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, uploadfile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, uploadfile.FieldUpdatedAt)
	}
	if m.photo_key != nil {
		fields = append(fields, uploadfile.FieldPhotoKey)
	}
	if m.user_id != nil {
		fields = append(fields, uploadfile.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UploadFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case uploadfile.FieldCreatedAt:
		return m.CreatedAt()
	case uploadfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case uploadfile.FieldPhotoKey:
		return m.PhotoKey()
	case uploadfile.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UploadFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case uploadfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case uploadfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case uploadfile.FieldPhotoKey:
		return m.OldPhotoKey(ctx)
	case uploadfile.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown UploadFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UploadFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case uploadfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case uploadfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case uploadfile.FieldPhotoKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoKey(v)
		return nil
	case uploadfile.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UploadFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UploadFileMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, uploadfile.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UploadFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case uploadfile.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UploadFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case uploadfile.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UploadFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UploadFileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UploadFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UploadFileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UploadFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UploadFileMutation) ResetField(name string) error {
	switch name {
	case uploadfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case uploadfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case uploadfile.FieldPhotoKey:
		m.ResetPhotoKey()
		return nil
	case uploadfile.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown UploadFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UploadFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._LessonPlan != nil {
		edges = append(edges, uploadfile.EdgeLessonPlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UploadFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case uploadfile.EdgeLessonPlan:
		if id := m._LessonPlan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UploadFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UploadFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UploadFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_LessonPlan {
		edges = append(edges, uploadfile.EdgeLessonPlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UploadFileMutation) EdgeCleared(name string) bool {
	switch name {
	case uploadfile.EdgeLessonPlan:
		return m.cleared_LessonPlan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UploadFileMutation) ClearEdge(name string) error {
	switch name {
	case uploadfile.EdgeLessonPlan:
		m.ClearLessonPlan()
		return nil
	}
	return fmt.Errorf("unknown UploadFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UploadFileMutation) ResetEdge(name string) error {
	switch name {
	case uploadfile.EdgeLessonPlan:
		m.ResetLessonPlan()
		return nil
	}
	return fmt.Errorf("unknown UploadFile edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	created_at                 *time.Time
	updated_at                 *time.Time
	user_type                  *user.UserType
	first_name                 *string
	family_name                *string
	email                      *string
	phone_number               *string
	password                   *string
	clearedFields              map[string]struct{}
	school                     *int
	clearedschool              bool
	company                    *int
	clearedcompany             bool
	inquiries                  map[int]struct{}
	removedinquiries           map[int]struct{}
	clearedinquiries           bool
	lesson_reservations        map[int]struct{}
	removedlesson_reservations map[int]struct{}
	clearedlesson_reservations bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserType sets the "user_type" field.
func (m *UserMutation) SetUserType(ut user.UserType) {
	m.user_type = &ut
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *UserMutation) UserType() (r user.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserType(ctx context.Context) (v user.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ResetUserType resets all changes to the "user_type" field.
func (m *UserMutation) ResetUserType() {
	m.user_type = nil
}

// SetSchoolID sets the "school_id" field.
func (m *UserMutation) SetSchoolID(i int) {
	m.school = &i
}

// SchoolID returns the value of the "school_id" field in the mutation.
func (m *UserMutation) SchoolID() (r int, exists bool) {
	v := m.school
	if v == nil {
		return
	}
	return *v, true
}

// OldSchoolID returns the old "school_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSchoolID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchoolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchoolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchoolID: %w", err)
	}
	return oldValue.SchoolID, nil
}

// ClearSchoolID clears the value of the "school_id" field.
func (m *UserMutation) ClearSchoolID() {
	m.school = nil
	m.clearedFields[user.FieldSchoolID] = struct{}{}
}

// SchoolIDCleared returns if the "school_id" field was cleared in this mutation.
func (m *UserMutation) SchoolIDCleared() bool {
	_, ok := m.clearedFields[user.FieldSchoolID]
	return ok
}

// ResetSchoolID resets all changes to the "school_id" field.
func (m *UserMutation) ResetSchoolID() {
	m.school = nil
	delete(m.clearedFields, user.FieldSchoolID)
}

// SetCompanyID sets the "company_id" field.
func (m *UserMutation) SetCompanyID(i int) {
	m.company = &i
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *UserMutation) CompanyID() (r int, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCompanyID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// ClearCompanyID clears the value of the "company_id" field.
func (m *UserMutation) ClearCompanyID() {
	m.company = nil
	m.clearedFields[user.FieldCompanyID] = struct{}{}
}

// CompanyIDCleared returns if the "company_id" field was cleared in this mutation.
func (m *UserMutation) CompanyIDCleared() bool {
	_, ok := m.clearedFields[user.FieldCompanyID]
	return ok
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *UserMutation) ResetCompanyID() {
	m.company = nil
	delete(m.clearedFields, user.FieldCompanyID)
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetFamilyName sets the "family_name" field.
func (m *UserMutation) SetFamilyName(s string) {
	m.family_name = &s
}

// FamilyName returns the value of the "family_name" field in the mutation.
func (m *UserMutation) FamilyName() (r string, exists bool) {
	v := m.family_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyName returns the old "family_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFamilyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamilyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamilyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyName: %w", err)
	}
	return oldValue.FamilyName, nil
}

// ResetFamilyName resets all changes to the "family_name" field.
func (m *UserMutation) ResetFamilyName() {
	m.family_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// ClearSchool clears the "school" edge to the School entity.
func (m *UserMutation) ClearSchool() {
	m.clearedschool = true
	m.clearedFields[user.FieldSchoolID] = struct{}{}
}

// SchoolCleared reports if the "school" edge to the School entity was cleared.
func (m *UserMutation) SchoolCleared() bool {
	return m.SchoolIDCleared() || m.clearedschool
}

// SchoolIDs returns the "school" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchoolID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SchoolIDs() (ids []int) {
	if id := m.school; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchool resets all changes to the "school" edge.
func (m *UserMutation) ResetSchool() {
	m.school = nil
	m.clearedschool = false
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *UserMutation) ClearCompany() {
	m.clearedcompany = true
	m.clearedFields[user.FieldCompanyID] = struct{}{}
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *UserMutation) CompanyCleared() bool {
	return m.CompanyIDCleared() || m.clearedcompany
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddInquiryIDs adds the "inquiries" edge to the Inquiry entity by ids.
func (m *UserMutation) AddInquiryIDs(ids ...int) {
	if m.inquiries == nil {
		m.inquiries = make(map[int]struct{})
	}
	for i := range ids {
		m.inquiries[ids[i]] = struct{}{}
	}
}

// ClearInquiries clears the "inquiries" edge to the Inquiry entity.
func (m *UserMutation) ClearInquiries() {
	m.clearedinquiries = true
}

// InquiriesCleared reports if the "inquiries" edge to the Inquiry entity was cleared.
func (m *UserMutation) InquiriesCleared() bool {
	return m.clearedinquiries
}

// RemoveInquiryIDs removes the "inquiries" edge to the Inquiry entity by IDs.
func (m *UserMutation) RemoveInquiryIDs(ids ...int) {
	if m.removedinquiries == nil {
		m.removedinquiries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inquiries, ids[i])
		m.removedinquiries[ids[i]] = struct{}{}
	}
}

// RemovedInquiries returns the removed IDs of the "inquiries" edge to the Inquiry entity.
func (m *UserMutation) RemovedInquiriesIDs() (ids []int) {
	for id := range m.removedinquiries {
		ids = append(ids, id)
	}
	return
}

// InquiriesIDs returns the "inquiries" edge IDs in the mutation.
func (m *UserMutation) InquiriesIDs() (ids []int) {
	for id := range m.inquiries {
		ids = append(ids, id)
	}
	return
}

// ResetInquiries resets all changes to the "inquiries" edge.
func (m *UserMutation) ResetInquiries() {
	m.inquiries = nil
	m.clearedinquiries = false
	m.removedinquiries = nil
}

// AddLessonReservationIDs adds the "lesson_reservations" edge to the LessonReservation entity by ids.
func (m *UserMutation) AddLessonReservationIDs(ids ...int) {
	if m.lesson_reservations == nil {
		m.lesson_reservations = make(map[int]struct{})
	}
	for i := range ids {
		m.lesson_reservations[ids[i]] = struct{}{}
	}
}

// ClearLessonReservations clears the "lesson_reservations" edge to the LessonReservation entity.
func (m *UserMutation) ClearLessonReservations() {
	m.clearedlesson_reservations = true
}

// LessonReservationsCleared reports if the "lesson_reservations" edge to the LessonReservation entity was cleared.
func (m *UserMutation) LessonReservationsCleared() bool {
	return m.clearedlesson_reservations
}

// RemoveLessonReservationIDs removes the "lesson_reservations" edge to the LessonReservation entity by IDs.
func (m *UserMutation) RemoveLessonReservationIDs(ids ...int) {
	if m.removedlesson_reservations == nil {
		m.removedlesson_reservations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lesson_reservations, ids[i])
		m.removedlesson_reservations[ids[i]] = struct{}{}
	}
}

// RemovedLessonReservations returns the removed IDs of the "lesson_reservations" edge to the LessonReservation entity.
func (m *UserMutation) RemovedLessonReservationsIDs() (ids []int) {
	for id := range m.removedlesson_reservations {
		ids = append(ids, id)
	}
	return
}

// LessonReservationsIDs returns the "lesson_reservations" edge IDs in the mutation.
func (m *UserMutation) LessonReservationsIDs() (ids []int) {
	for id := range m.lesson_reservations {
		ids = append(ids, id)
	}
	return
}

// ResetLessonReservations resets all changes to the "lesson_reservations" edge.
func (m *UserMutation) ResetLessonReservations() {
	m.lesson_reservations = nil
	m.clearedlesson_reservations = false
	m.removedlesson_reservations = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.user_type != nil {
		fields = append(fields, user.FieldUserType)
	}
	if m.school != nil {
		fields = append(fields, user.FieldSchoolID)
	}
	if m.company != nil {
		fields = append(fields, user.FieldCompanyID)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.family_name != nil {
		fields = append(fields, user.FieldFamilyName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUserType:
		return m.UserType()
	case user.FieldSchoolID:
		return m.SchoolID()
	case user.FieldCompanyID:
		return m.CompanyID()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldFamilyName:
		return m.FamilyName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUserType:
		return m.OldUserType(ctx)
	case user.FieldSchoolID:
		return m.OldSchoolID(ctx)
	case user.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldFamilyName:
		return m.OldFamilyName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUserType:
		v, ok := value.(user.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case user.FieldSchoolID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchoolID(v)
		return nil
	case user.FieldCompanyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldFamilyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldSchoolID) {
		fields = append(fields, user.FieldSchoolID)
	}
	if m.FieldCleared(user.FieldCompanyID) {
		fields = append(fields, user.FieldCompanyID)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldSchoolID:
		m.ClearSchoolID()
		return nil
	case user.FieldCompanyID:
		m.ClearCompanyID()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUserType:
		m.ResetUserType()
		return nil
	case user.FieldSchoolID:
		m.ResetSchoolID()
		return nil
	case user.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldFamilyName:
		m.ResetFamilyName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.school != nil {
		edges = append(edges, user.EdgeSchool)
	}
	if m.company != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.inquiries != nil {
		edges = append(edges, user.EdgeInquiries)
	}
	if m.lesson_reservations != nil {
		edges = append(edges, user.EdgeLessonReservations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSchool:
		if id := m.school; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeInquiries:
		ids := make([]ent.Value, 0, len(m.inquiries))
		for id := range m.inquiries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLessonReservations:
		ids := make([]ent.Value, 0, len(m.lesson_reservations))
		for id := range m.lesson_reservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedinquiries != nil {
		edges = append(edges, user.EdgeInquiries)
	}
	if m.removedlesson_reservations != nil {
		edges = append(edges, user.EdgeLessonReservations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeInquiries:
		ids := make([]ent.Value, 0, len(m.removedinquiries))
		for id := range m.removedinquiries {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLessonReservations:
		ids := make([]ent.Value, 0, len(m.removedlesson_reservations))
		for id := range m.removedlesson_reservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedschool {
		edges = append(edges, user.EdgeSchool)
	}
	if m.clearedcompany {
		edges = append(edges, user.EdgeCompany)
	}
	if m.clearedinquiries {
		edges = append(edges, user.EdgeInquiries)
	}
	if m.clearedlesson_reservations {
		edges = append(edges, user.EdgeLessonReservations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSchool:
		return m.clearedschool
	case user.EdgeCompany:
		return m.clearedcompany
	case user.EdgeInquiries:
		return m.clearedinquiries
	case user.EdgeLessonReservations:
		return m.clearedlesson_reservations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeSchool:
		m.ClearSchool()
		return nil
	case user.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSchool:
		m.ResetSchool()
		return nil
	case user.EdgeCompany:
		m.ResetCompany()
		return nil
	case user.EdgeInquiries:
		m.ResetInquiries()
		return nil
	case user.EdgeLessonReservations:
		m.ResetLessonReservations()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
