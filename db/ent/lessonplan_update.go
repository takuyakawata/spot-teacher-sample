// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/company"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/educationcategory"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/grade"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonplan"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonschedule"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/predicate"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/subject"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/uploadfile"
)

// LessonPlanUpdate is the builder for updating LessonPlan entities.
type LessonPlanUpdate struct {
	config
	hooks    []Hook
	mutation *LessonPlanMutation
}

// Where appends a list predicates to the LessonPlanUpdate builder.
func (lpu *LessonPlanUpdate) Where(ps ...predicate.LessonPlan) *LessonPlanUpdate {
	lpu.mutation.Where(ps...)
	return lpu
}

// SetUpdatedAt sets the "updated_at" field.
func (lpu *LessonPlanUpdate) SetUpdatedAt(t time.Time) *LessonPlanUpdate {
	lpu.mutation.SetUpdatedAt(t)
	return lpu
}

// SetCompanyID sets the "company_id" field.
func (lpu *LessonPlanUpdate) SetCompanyID(i int) *LessonPlanUpdate {
	lpu.mutation.SetCompanyID(i)
	return lpu
}

// SetNillableCompanyID sets the "company_id" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableCompanyID(i *int) *LessonPlanUpdate {
	if i != nil {
		lpu.SetCompanyID(*i)
	}
	return lpu
}

// SetTitle sets the "title" field.
func (lpu *LessonPlanUpdate) SetTitle(s string) *LessonPlanUpdate {
	lpu.mutation.SetTitle(s)
	return lpu
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableTitle(s *string) *LessonPlanUpdate {
	if s != nil {
		lpu.SetTitle(*s)
	}
	return lpu
}

// SetDescription sets the "description" field.
func (lpu *LessonPlanUpdate) SetDescription(s string) *LessonPlanUpdate {
	lpu.mutation.SetDescription(s)
	return lpu
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableDescription(s *string) *LessonPlanUpdate {
	if s != nil {
		lpu.SetDescription(*s)
	}
	return lpu
}

// ClearDescription clears the value of the "description" field.
func (lpu *LessonPlanUpdate) ClearDescription() *LessonPlanUpdate {
	lpu.mutation.ClearDescription()
	return lpu
}

// SetLocation sets the "location" field.
func (lpu *LessonPlanUpdate) SetLocation(s string) *LessonPlanUpdate {
	lpu.mutation.SetLocation(s)
	return lpu
}

// SetNillableLocation sets the "location" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableLocation(s *string) *LessonPlanUpdate {
	if s != nil {
		lpu.SetLocation(*s)
	}
	return lpu
}

// ClearLocation clears the value of the "location" field.
func (lpu *LessonPlanUpdate) ClearLocation() *LessonPlanUpdate {
	lpu.mutation.ClearLocation()
	return lpu
}

// SetLessonType sets the "lesson_type" field.
func (lpu *LessonPlanUpdate) SetLessonType(lt lessonplan.LessonType) *LessonPlanUpdate {
	lpu.mutation.SetLessonType(lt)
	return lpu
}

// SetNillableLessonType sets the "lesson_type" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableLessonType(lt *lessonplan.LessonType) *LessonPlanUpdate {
	if lt != nil {
		lpu.SetLessonType(*lt)
	}
	return lpu
}

// SetAnnualMaxExecutions sets the "annual_max_executions" field.
func (lpu *LessonPlanUpdate) SetAnnualMaxExecutions(i int) *LessonPlanUpdate {
	lpu.mutation.ResetAnnualMaxExecutions()
	lpu.mutation.SetAnnualMaxExecutions(i)
	return lpu
}

// SetNillableAnnualMaxExecutions sets the "annual_max_executions" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableAnnualMaxExecutions(i *int) *LessonPlanUpdate {
	if i != nil {
		lpu.SetAnnualMaxExecutions(*i)
	}
	return lpu
}

// AddAnnualMaxExecutions adds i to the "annual_max_executions" field.
func (lpu *LessonPlanUpdate) AddAnnualMaxExecutions(i int) *LessonPlanUpdate {
	lpu.mutation.AddAnnualMaxExecutions(i)
	return lpu
}

// SetStartMonth sets the "start_month" field.
func (lpu *LessonPlanUpdate) SetStartMonth(i int) *LessonPlanUpdate {
	lpu.mutation.ResetStartMonth()
	lpu.mutation.SetStartMonth(i)
	return lpu
}

// SetNillableStartMonth sets the "start_month" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableStartMonth(i *int) *LessonPlanUpdate {
	if i != nil {
		lpu.SetStartMonth(*i)
	}
	return lpu
}

// AddStartMonth adds i to the "start_month" field.
func (lpu *LessonPlanUpdate) AddStartMonth(i int) *LessonPlanUpdate {
	lpu.mutation.AddStartMonth(i)
	return lpu
}

// SetStartDay sets the "start_day" field.
func (lpu *LessonPlanUpdate) SetStartDay(i int) *LessonPlanUpdate {
	lpu.mutation.ResetStartDay()
	lpu.mutation.SetStartDay(i)
	return lpu
}

// SetNillableStartDay sets the "start_day" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableStartDay(i *int) *LessonPlanUpdate {
	if i != nil {
		lpu.SetStartDay(*i)
	}
	return lpu
}

// AddStartDay adds i to the "start_day" field.
func (lpu *LessonPlanUpdate) AddStartDay(i int) *LessonPlanUpdate {
	lpu.mutation.AddStartDay(i)
	return lpu
}

// SetEndMonth sets the "end_month" field.
func (lpu *LessonPlanUpdate) SetEndMonth(i int) *LessonPlanUpdate {
	lpu.mutation.ResetEndMonth()
	lpu.mutation.SetEndMonth(i)
	return lpu
}

// SetNillableEndMonth sets the "end_month" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableEndMonth(i *int) *LessonPlanUpdate {
	if i != nil {
		lpu.SetEndMonth(*i)
	}
	return lpu
}

// AddEndMonth adds i to the "end_month" field.
func (lpu *LessonPlanUpdate) AddEndMonth(i int) *LessonPlanUpdate {
	lpu.mutation.AddEndMonth(i)
	return lpu
}

// SetEndDay sets the "end_day" field.
func (lpu *LessonPlanUpdate) SetEndDay(i int) *LessonPlanUpdate {
	lpu.mutation.ResetEndDay()
	lpu.mutation.SetEndDay(i)
	return lpu
}

// SetNillableEndDay sets the "end_day" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableEndDay(i *int) *LessonPlanUpdate {
	if i != nil {
		lpu.SetEndDay(*i)
	}
	return lpu
}

// AddEndDay adds i to the "end_day" field.
func (lpu *LessonPlanUpdate) AddEndDay(i int) *LessonPlanUpdate {
	lpu.mutation.AddEndDay(i)
	return lpu
}

// SetStartTime sets the "start_time" field.
func (lpu *LessonPlanUpdate) SetStartTime(t time.Time) *LessonPlanUpdate {
	lpu.mutation.SetStartTime(t)
	return lpu
}

// SetNillableStartTime sets the "start_time" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableStartTime(t *time.Time) *LessonPlanUpdate {
	if t != nil {
		lpu.SetStartTime(*t)
	}
	return lpu
}

// SetEndTime sets the "end_time" field.
func (lpu *LessonPlanUpdate) SetEndTime(t time.Time) *LessonPlanUpdate {
	lpu.mutation.SetEndTime(t)
	return lpu
}

// SetNillableEndTime sets the "end_time" field if the given value is not nil.
func (lpu *LessonPlanUpdate) SetNillableEndTime(t *time.Time) *LessonPlanUpdate {
	if t != nil {
		lpu.SetEndTime(*t)
	}
	return lpu
}

// SetCompany sets the "company" edge to the Company entity.
func (lpu *LessonPlanUpdate) SetCompany(c *Company) *LessonPlanUpdate {
	return lpu.SetCompanyID(c.ID)
}

// AddScheduleIDs adds the "schedules" edge to the LessonSchedule entity by IDs.
func (lpu *LessonPlanUpdate) AddScheduleIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.AddScheduleIDs(ids...)
	return lpu
}

// AddSchedules adds the "schedules" edges to the LessonSchedule entity.
func (lpu *LessonPlanUpdate) AddSchedules(l ...*LessonSchedule) *LessonPlanUpdate {
	ids := make([]int, len(l))
	for i := range l {
		ids[i] = l[i].ID
	}
	return lpu.AddScheduleIDs(ids...)
}

// AddGradeIDs adds the "grades" edge to the Grade entity by IDs.
func (lpu *LessonPlanUpdate) AddGradeIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.AddGradeIDs(ids...)
	return lpu
}

// AddGrades adds the "grades" edges to the Grade entity.
func (lpu *LessonPlanUpdate) AddGrades(g ...*Grade) *LessonPlanUpdate {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return lpu.AddGradeIDs(ids...)
}

// AddSubjectIDs adds the "subjects" edge to the Subject entity by IDs.
func (lpu *LessonPlanUpdate) AddSubjectIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.AddSubjectIDs(ids...)
	return lpu
}

// AddSubjects adds the "subjects" edges to the Subject entity.
func (lpu *LessonPlanUpdate) AddSubjects(s ...*Subject) *LessonPlanUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return lpu.AddSubjectIDs(ids...)
}

// AddEducationCategoryIDs adds the "education_categories" edge to the EducationCategory entity by IDs.
func (lpu *LessonPlanUpdate) AddEducationCategoryIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.AddEducationCategoryIDs(ids...)
	return lpu
}

// AddEducationCategories adds the "education_categories" edges to the EducationCategory entity.
func (lpu *LessonPlanUpdate) AddEducationCategories(e ...*EducationCategory) *LessonPlanUpdate {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return lpu.AddEducationCategoryIDs(ids...)
}

// AddUploadFileIDs adds the "upload_files" edge to the UploadFile entity by IDs.
func (lpu *LessonPlanUpdate) AddUploadFileIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.AddUploadFileIDs(ids...)
	return lpu
}

// AddUploadFiles adds the "upload_files" edges to the UploadFile entity.
func (lpu *LessonPlanUpdate) AddUploadFiles(u ...*UploadFile) *LessonPlanUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return lpu.AddUploadFileIDs(ids...)
}

// Mutation returns the LessonPlanMutation object of the builder.
func (lpu *LessonPlanUpdate) Mutation() *LessonPlanMutation {
	return lpu.mutation
}

// ClearCompany clears the "company" edge to the Company entity.
func (lpu *LessonPlanUpdate) ClearCompany() *LessonPlanUpdate {
	lpu.mutation.ClearCompany()
	return lpu
}

// ClearSchedules clears all "schedules" edges to the LessonSchedule entity.
func (lpu *LessonPlanUpdate) ClearSchedules() *LessonPlanUpdate {
	lpu.mutation.ClearSchedules()
	return lpu
}

// RemoveScheduleIDs removes the "schedules" edge to LessonSchedule entities by IDs.
func (lpu *LessonPlanUpdate) RemoveScheduleIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.RemoveScheduleIDs(ids...)
	return lpu
}

// RemoveSchedules removes "schedules" edges to LessonSchedule entities.
func (lpu *LessonPlanUpdate) RemoveSchedules(l ...*LessonSchedule) *LessonPlanUpdate {
	ids := make([]int, len(l))
	for i := range l {
		ids[i] = l[i].ID
	}
	return lpu.RemoveScheduleIDs(ids...)
}

// ClearGrades clears all "grades" edges to the Grade entity.
func (lpu *LessonPlanUpdate) ClearGrades() *LessonPlanUpdate {
	lpu.mutation.ClearGrades()
	return lpu
}

// RemoveGradeIDs removes the "grades" edge to Grade entities by IDs.
func (lpu *LessonPlanUpdate) RemoveGradeIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.RemoveGradeIDs(ids...)
	return lpu
}

// RemoveGrades removes "grades" edges to Grade entities.
func (lpu *LessonPlanUpdate) RemoveGrades(g ...*Grade) *LessonPlanUpdate {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return lpu.RemoveGradeIDs(ids...)
}

// ClearSubjects clears all "subjects" edges to the Subject entity.
func (lpu *LessonPlanUpdate) ClearSubjects() *LessonPlanUpdate {
	lpu.mutation.ClearSubjects()
	return lpu
}

// RemoveSubjectIDs removes the "subjects" edge to Subject entities by IDs.
func (lpu *LessonPlanUpdate) RemoveSubjectIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.RemoveSubjectIDs(ids...)
	return lpu
}

// RemoveSubjects removes "subjects" edges to Subject entities.
func (lpu *LessonPlanUpdate) RemoveSubjects(s ...*Subject) *LessonPlanUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return lpu.RemoveSubjectIDs(ids...)
}

// ClearEducationCategories clears all "education_categories" edges to the EducationCategory entity.
func (lpu *LessonPlanUpdate) ClearEducationCategories() *LessonPlanUpdate {
	lpu.mutation.ClearEducationCategories()
	return lpu
}

// RemoveEducationCategoryIDs removes the "education_categories" edge to EducationCategory entities by IDs.
func (lpu *LessonPlanUpdate) RemoveEducationCategoryIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.RemoveEducationCategoryIDs(ids...)
	return lpu
}

// RemoveEducationCategories removes "education_categories" edges to EducationCategory entities.
func (lpu *LessonPlanUpdate) RemoveEducationCategories(e ...*EducationCategory) *LessonPlanUpdate {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return lpu.RemoveEducationCategoryIDs(ids...)
}

// ClearUploadFiles clears all "upload_files" edges to the UploadFile entity.
func (lpu *LessonPlanUpdate) ClearUploadFiles() *LessonPlanUpdate {
	lpu.mutation.ClearUploadFiles()
	return lpu
}

// RemoveUploadFileIDs removes the "upload_files" edge to UploadFile entities by IDs.
func (lpu *LessonPlanUpdate) RemoveUploadFileIDs(ids ...int) *LessonPlanUpdate {
	lpu.mutation.RemoveUploadFileIDs(ids...)
	return lpu
}

// RemoveUploadFiles removes "upload_files" edges to UploadFile entities.
func (lpu *LessonPlanUpdate) RemoveUploadFiles(u ...*UploadFile) *LessonPlanUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return lpu.RemoveUploadFileIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (lpu *LessonPlanUpdate) Save(ctx context.Context) (int, error) {
	lpu.defaults()
	return withHooks(ctx, lpu.sqlSave, lpu.mutation, lpu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (lpu *LessonPlanUpdate) SaveX(ctx context.Context) int {
	affected, err := lpu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (lpu *LessonPlanUpdate) Exec(ctx context.Context) error {
	_, err := lpu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (lpu *LessonPlanUpdate) ExecX(ctx context.Context) {
	if err := lpu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (lpu *LessonPlanUpdate) defaults() {
	if _, ok := lpu.mutation.UpdatedAt(); !ok {
		v := lessonplan.UpdateDefaultUpdatedAt()
		lpu.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (lpu *LessonPlanUpdate) check() error {
	if v, ok := lpu.mutation.CompanyID(); ok {
		if err := lessonplan.CompanyIDValidator(v); err != nil {
			return &ValidationError{Name: "company_id", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.company_id": %w`, err)}
		}
	}
	if v, ok := lpu.mutation.Title(); ok {
		if err := lessonplan.TitleValidator(v); err != nil {
			return &ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.title": %w`, err)}
		}
	}
	if v, ok := lpu.mutation.Description(); ok {
		if err := lessonplan.DescriptionValidator(v); err != nil {
			return &ValidationError{Name: "description", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.description": %w`, err)}
		}
	}
	if v, ok := lpu.mutation.Location(); ok {
		if err := lessonplan.LocationValidator(v); err != nil {
			return &ValidationError{Name: "location", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.location": %w`, err)}
		}
	}
	if v, ok := lpu.mutation.LessonType(); ok {
		if err := lessonplan.LessonTypeValidator(v); err != nil {
			return &ValidationError{Name: "lesson_type", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.lesson_type": %w`, err)}
		}
	}
	if v, ok := lpu.mutation.AnnualMaxExecutions(); ok {
		if err := lessonplan.AnnualMaxExecutionsValidator(v); err != nil {
			return &ValidationError{Name: "annual_max_executions", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.annual_max_executions": %w`, err)}
		}
	}
	if v, ok := lpu.mutation.StartMonth(); ok {
		if err := lessonplan.StartMonthValidator(v); err != nil {
			return &ValidationError{Name: "start_month", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.start_month": %w`, err)}
		}
	}
	if v, ok := lpu.mutation.StartDay(); ok {
		if err := lessonplan.StartDayValidator(v); err != nil {
			return &ValidationError{Name: "start_day", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.start_day": %w`, err)}
		}
	}
	if v, ok := lpu.mutation.EndMonth(); ok {
		if err := lessonplan.EndMonthValidator(v); err != nil {
			return &ValidationError{Name: "end_month", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.end_month": %w`, err)}
		}
	}
	if v, ok := lpu.mutation.EndDay(); ok {
		if err := lessonplan.EndDayValidator(v); err != nil {
			return &ValidationError{Name: "end_day", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.end_day": %w`, err)}
		}
	}
	if lpu.mutation.CompanyCleared() && len(lpu.mutation.CompanyIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "LessonPlan.company"`)
	}
	return nil
}

func (lpu *LessonPlanUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := lpu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(lessonplan.Table, lessonplan.Columns, sqlgraph.NewFieldSpec(lessonplan.FieldID, field.TypeInt))
	if ps := lpu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := lpu.mutation.UpdatedAt(); ok {
		_spec.SetField(lessonplan.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := lpu.mutation.Title(); ok {
		_spec.SetField(lessonplan.FieldTitle, field.TypeString, value)
	}
	if value, ok := lpu.mutation.Description(); ok {
		_spec.SetField(lessonplan.FieldDescription, field.TypeString, value)
	}
	if lpu.mutation.DescriptionCleared() {
		_spec.ClearField(lessonplan.FieldDescription, field.TypeString)
	}
	if value, ok := lpu.mutation.Location(); ok {
		_spec.SetField(lessonplan.FieldLocation, field.TypeString, value)
	}
	if lpu.mutation.LocationCleared() {
		_spec.ClearField(lessonplan.FieldLocation, field.TypeString)
	}
	if value, ok := lpu.mutation.LessonType(); ok {
		_spec.SetField(lessonplan.FieldLessonType, field.TypeEnum, value)
	}
	if value, ok := lpu.mutation.AnnualMaxExecutions(); ok {
		_spec.SetField(lessonplan.FieldAnnualMaxExecutions, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.AddedAnnualMaxExecutions(); ok {
		_spec.AddField(lessonplan.FieldAnnualMaxExecutions, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.StartMonth(); ok {
		_spec.SetField(lessonplan.FieldStartMonth, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.AddedStartMonth(); ok {
		_spec.AddField(lessonplan.FieldStartMonth, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.StartDay(); ok {
		_spec.SetField(lessonplan.FieldStartDay, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.AddedStartDay(); ok {
		_spec.AddField(lessonplan.FieldStartDay, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.EndMonth(); ok {
		_spec.SetField(lessonplan.FieldEndMonth, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.AddedEndMonth(); ok {
		_spec.AddField(lessonplan.FieldEndMonth, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.EndDay(); ok {
		_spec.SetField(lessonplan.FieldEndDay, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.AddedEndDay(); ok {
		_spec.AddField(lessonplan.FieldEndDay, field.TypeInt, value)
	}
	if value, ok := lpu.mutation.StartTime(); ok {
		_spec.SetField(lessonplan.FieldStartTime, field.TypeTime, value)
	}
	if value, ok := lpu.mutation.EndTime(); ok {
		_spec.SetField(lessonplan.FieldEndTime, field.TypeTime, value)
	}
	if lpu.mutation.CompanyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   lessonplan.CompanyTable,
			Columns: []string{lessonplan.CompanyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(company.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.CompanyIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   lessonplan.CompanyTable,
			Columns: []string{lessonplan.CompanyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(company.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpu.mutation.SchedulesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.SchedulesTable,
			Columns: []string{lessonplan.SchedulesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonschedule.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.RemovedSchedulesIDs(); len(nodes) > 0 && !lpu.mutation.SchedulesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.SchedulesTable,
			Columns: []string{lessonplan.SchedulesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonschedule.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.SchedulesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.SchedulesTable,
			Columns: []string{lessonplan.SchedulesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonschedule.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpu.mutation.GradesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.GradesTable,
			Columns: lessonplan.GradesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.RemovedGradesIDs(); len(nodes) > 0 && !lpu.mutation.GradesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.GradesTable,
			Columns: lessonplan.GradesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.GradesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.GradesTable,
			Columns: lessonplan.GradesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpu.mutation.SubjectsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.SubjectsTable,
			Columns: lessonplan.SubjectsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.RemovedSubjectsIDs(); len(nodes) > 0 && !lpu.mutation.SubjectsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.SubjectsTable,
			Columns: lessonplan.SubjectsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.SubjectsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.SubjectsTable,
			Columns: lessonplan.SubjectsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpu.mutation.EducationCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.EducationCategoriesTable,
			Columns: lessonplan.EducationCategoriesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.RemovedEducationCategoriesIDs(); len(nodes) > 0 && !lpu.mutation.EducationCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.EducationCategoriesTable,
			Columns: lessonplan.EducationCategoriesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.EducationCategoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.EducationCategoriesTable,
			Columns: lessonplan.EducationCategoriesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpu.mutation.UploadFilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.UploadFilesTable,
			Columns: []string{lessonplan.UploadFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(uploadfile.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.RemovedUploadFilesIDs(); len(nodes) > 0 && !lpu.mutation.UploadFilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.UploadFilesTable,
			Columns: []string{lessonplan.UploadFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(uploadfile.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpu.mutation.UploadFilesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.UploadFilesTable,
			Columns: []string{lessonplan.UploadFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(uploadfile.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, lpu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{lessonplan.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	lpu.mutation.done = true
	return n, nil
}

// LessonPlanUpdateOne is the builder for updating a single LessonPlan entity.
type LessonPlanUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *LessonPlanMutation
}

// SetUpdatedAt sets the "updated_at" field.
func (lpuo *LessonPlanUpdateOne) SetUpdatedAt(t time.Time) *LessonPlanUpdateOne {
	lpuo.mutation.SetUpdatedAt(t)
	return lpuo
}

// SetCompanyID sets the "company_id" field.
func (lpuo *LessonPlanUpdateOne) SetCompanyID(i int) *LessonPlanUpdateOne {
	lpuo.mutation.SetCompanyID(i)
	return lpuo
}

// SetNillableCompanyID sets the "company_id" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableCompanyID(i *int) *LessonPlanUpdateOne {
	if i != nil {
		lpuo.SetCompanyID(*i)
	}
	return lpuo
}

// SetTitle sets the "title" field.
func (lpuo *LessonPlanUpdateOne) SetTitle(s string) *LessonPlanUpdateOne {
	lpuo.mutation.SetTitle(s)
	return lpuo
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableTitle(s *string) *LessonPlanUpdateOne {
	if s != nil {
		lpuo.SetTitle(*s)
	}
	return lpuo
}

// SetDescription sets the "description" field.
func (lpuo *LessonPlanUpdateOne) SetDescription(s string) *LessonPlanUpdateOne {
	lpuo.mutation.SetDescription(s)
	return lpuo
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableDescription(s *string) *LessonPlanUpdateOne {
	if s != nil {
		lpuo.SetDescription(*s)
	}
	return lpuo
}

// ClearDescription clears the value of the "description" field.
func (lpuo *LessonPlanUpdateOne) ClearDescription() *LessonPlanUpdateOne {
	lpuo.mutation.ClearDescription()
	return lpuo
}

// SetLocation sets the "location" field.
func (lpuo *LessonPlanUpdateOne) SetLocation(s string) *LessonPlanUpdateOne {
	lpuo.mutation.SetLocation(s)
	return lpuo
}

// SetNillableLocation sets the "location" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableLocation(s *string) *LessonPlanUpdateOne {
	if s != nil {
		lpuo.SetLocation(*s)
	}
	return lpuo
}

// ClearLocation clears the value of the "location" field.
func (lpuo *LessonPlanUpdateOne) ClearLocation() *LessonPlanUpdateOne {
	lpuo.mutation.ClearLocation()
	return lpuo
}

// SetLessonType sets the "lesson_type" field.
func (lpuo *LessonPlanUpdateOne) SetLessonType(lt lessonplan.LessonType) *LessonPlanUpdateOne {
	lpuo.mutation.SetLessonType(lt)
	return lpuo
}

// SetNillableLessonType sets the "lesson_type" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableLessonType(lt *lessonplan.LessonType) *LessonPlanUpdateOne {
	if lt != nil {
		lpuo.SetLessonType(*lt)
	}
	return lpuo
}

// SetAnnualMaxExecutions sets the "annual_max_executions" field.
func (lpuo *LessonPlanUpdateOne) SetAnnualMaxExecutions(i int) *LessonPlanUpdateOne {
	lpuo.mutation.ResetAnnualMaxExecutions()
	lpuo.mutation.SetAnnualMaxExecutions(i)
	return lpuo
}

// SetNillableAnnualMaxExecutions sets the "annual_max_executions" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableAnnualMaxExecutions(i *int) *LessonPlanUpdateOne {
	if i != nil {
		lpuo.SetAnnualMaxExecutions(*i)
	}
	return lpuo
}

// AddAnnualMaxExecutions adds i to the "annual_max_executions" field.
func (lpuo *LessonPlanUpdateOne) AddAnnualMaxExecutions(i int) *LessonPlanUpdateOne {
	lpuo.mutation.AddAnnualMaxExecutions(i)
	return lpuo
}

// SetStartMonth sets the "start_month" field.
func (lpuo *LessonPlanUpdateOne) SetStartMonth(i int) *LessonPlanUpdateOne {
	lpuo.mutation.ResetStartMonth()
	lpuo.mutation.SetStartMonth(i)
	return lpuo
}

// SetNillableStartMonth sets the "start_month" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableStartMonth(i *int) *LessonPlanUpdateOne {
	if i != nil {
		lpuo.SetStartMonth(*i)
	}
	return lpuo
}

// AddStartMonth adds i to the "start_month" field.
func (lpuo *LessonPlanUpdateOne) AddStartMonth(i int) *LessonPlanUpdateOne {
	lpuo.mutation.AddStartMonth(i)
	return lpuo
}

// SetStartDay sets the "start_day" field.
func (lpuo *LessonPlanUpdateOne) SetStartDay(i int) *LessonPlanUpdateOne {
	lpuo.mutation.ResetStartDay()
	lpuo.mutation.SetStartDay(i)
	return lpuo
}

// SetNillableStartDay sets the "start_day" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableStartDay(i *int) *LessonPlanUpdateOne {
	if i != nil {
		lpuo.SetStartDay(*i)
	}
	return lpuo
}

// AddStartDay adds i to the "start_day" field.
func (lpuo *LessonPlanUpdateOne) AddStartDay(i int) *LessonPlanUpdateOne {
	lpuo.mutation.AddStartDay(i)
	return lpuo
}

// SetEndMonth sets the "end_month" field.
func (lpuo *LessonPlanUpdateOne) SetEndMonth(i int) *LessonPlanUpdateOne {
	lpuo.mutation.ResetEndMonth()
	lpuo.mutation.SetEndMonth(i)
	return lpuo
}

// SetNillableEndMonth sets the "end_month" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableEndMonth(i *int) *LessonPlanUpdateOne {
	if i != nil {
		lpuo.SetEndMonth(*i)
	}
	return lpuo
}

// AddEndMonth adds i to the "end_month" field.
func (lpuo *LessonPlanUpdateOne) AddEndMonth(i int) *LessonPlanUpdateOne {
	lpuo.mutation.AddEndMonth(i)
	return lpuo
}

// SetEndDay sets the "end_day" field.
func (lpuo *LessonPlanUpdateOne) SetEndDay(i int) *LessonPlanUpdateOne {
	lpuo.mutation.ResetEndDay()
	lpuo.mutation.SetEndDay(i)
	return lpuo
}

// SetNillableEndDay sets the "end_day" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableEndDay(i *int) *LessonPlanUpdateOne {
	if i != nil {
		lpuo.SetEndDay(*i)
	}
	return lpuo
}

// AddEndDay adds i to the "end_day" field.
func (lpuo *LessonPlanUpdateOne) AddEndDay(i int) *LessonPlanUpdateOne {
	lpuo.mutation.AddEndDay(i)
	return lpuo
}

// SetStartTime sets the "start_time" field.
func (lpuo *LessonPlanUpdateOne) SetStartTime(t time.Time) *LessonPlanUpdateOne {
	lpuo.mutation.SetStartTime(t)
	return lpuo
}

// SetNillableStartTime sets the "start_time" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableStartTime(t *time.Time) *LessonPlanUpdateOne {
	if t != nil {
		lpuo.SetStartTime(*t)
	}
	return lpuo
}

// SetEndTime sets the "end_time" field.
func (lpuo *LessonPlanUpdateOne) SetEndTime(t time.Time) *LessonPlanUpdateOne {
	lpuo.mutation.SetEndTime(t)
	return lpuo
}

// SetNillableEndTime sets the "end_time" field if the given value is not nil.
func (lpuo *LessonPlanUpdateOne) SetNillableEndTime(t *time.Time) *LessonPlanUpdateOne {
	if t != nil {
		lpuo.SetEndTime(*t)
	}
	return lpuo
}

// SetCompany sets the "company" edge to the Company entity.
func (lpuo *LessonPlanUpdateOne) SetCompany(c *Company) *LessonPlanUpdateOne {
	return lpuo.SetCompanyID(c.ID)
}

// AddScheduleIDs adds the "schedules" edge to the LessonSchedule entity by IDs.
func (lpuo *LessonPlanUpdateOne) AddScheduleIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.AddScheduleIDs(ids...)
	return lpuo
}

// AddSchedules adds the "schedules" edges to the LessonSchedule entity.
func (lpuo *LessonPlanUpdateOne) AddSchedules(l ...*LessonSchedule) *LessonPlanUpdateOne {
	ids := make([]int, len(l))
	for i := range l {
		ids[i] = l[i].ID
	}
	return lpuo.AddScheduleIDs(ids...)
}

// AddGradeIDs adds the "grades" edge to the Grade entity by IDs.
func (lpuo *LessonPlanUpdateOne) AddGradeIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.AddGradeIDs(ids...)
	return lpuo
}

// AddGrades adds the "grades" edges to the Grade entity.
func (lpuo *LessonPlanUpdateOne) AddGrades(g ...*Grade) *LessonPlanUpdateOne {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return lpuo.AddGradeIDs(ids...)
}

// AddSubjectIDs adds the "subjects" edge to the Subject entity by IDs.
func (lpuo *LessonPlanUpdateOne) AddSubjectIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.AddSubjectIDs(ids...)
	return lpuo
}

// AddSubjects adds the "subjects" edges to the Subject entity.
func (lpuo *LessonPlanUpdateOne) AddSubjects(s ...*Subject) *LessonPlanUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return lpuo.AddSubjectIDs(ids...)
}

// AddEducationCategoryIDs adds the "education_categories" edge to the EducationCategory entity by IDs.
func (lpuo *LessonPlanUpdateOne) AddEducationCategoryIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.AddEducationCategoryIDs(ids...)
	return lpuo
}

// AddEducationCategories adds the "education_categories" edges to the EducationCategory entity.
func (lpuo *LessonPlanUpdateOne) AddEducationCategories(e ...*EducationCategory) *LessonPlanUpdateOne {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return lpuo.AddEducationCategoryIDs(ids...)
}

// AddUploadFileIDs adds the "upload_files" edge to the UploadFile entity by IDs.
func (lpuo *LessonPlanUpdateOne) AddUploadFileIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.AddUploadFileIDs(ids...)
	return lpuo
}

// AddUploadFiles adds the "upload_files" edges to the UploadFile entity.
func (lpuo *LessonPlanUpdateOne) AddUploadFiles(u ...*UploadFile) *LessonPlanUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return lpuo.AddUploadFileIDs(ids...)
}

// Mutation returns the LessonPlanMutation object of the builder.
func (lpuo *LessonPlanUpdateOne) Mutation() *LessonPlanMutation {
	return lpuo.mutation
}

// ClearCompany clears the "company" edge to the Company entity.
func (lpuo *LessonPlanUpdateOne) ClearCompany() *LessonPlanUpdateOne {
	lpuo.mutation.ClearCompany()
	return lpuo
}

// ClearSchedules clears all "schedules" edges to the LessonSchedule entity.
func (lpuo *LessonPlanUpdateOne) ClearSchedules() *LessonPlanUpdateOne {
	lpuo.mutation.ClearSchedules()
	return lpuo
}

// RemoveScheduleIDs removes the "schedules" edge to LessonSchedule entities by IDs.
func (lpuo *LessonPlanUpdateOne) RemoveScheduleIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.RemoveScheduleIDs(ids...)
	return lpuo
}

// RemoveSchedules removes "schedules" edges to LessonSchedule entities.
func (lpuo *LessonPlanUpdateOne) RemoveSchedules(l ...*LessonSchedule) *LessonPlanUpdateOne {
	ids := make([]int, len(l))
	for i := range l {
		ids[i] = l[i].ID
	}
	return lpuo.RemoveScheduleIDs(ids...)
}

// ClearGrades clears all "grades" edges to the Grade entity.
func (lpuo *LessonPlanUpdateOne) ClearGrades() *LessonPlanUpdateOne {
	lpuo.mutation.ClearGrades()
	return lpuo
}

// RemoveGradeIDs removes the "grades" edge to Grade entities by IDs.
func (lpuo *LessonPlanUpdateOne) RemoveGradeIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.RemoveGradeIDs(ids...)
	return lpuo
}

// RemoveGrades removes "grades" edges to Grade entities.
func (lpuo *LessonPlanUpdateOne) RemoveGrades(g ...*Grade) *LessonPlanUpdateOne {
	ids := make([]int, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return lpuo.RemoveGradeIDs(ids...)
}

// ClearSubjects clears all "subjects" edges to the Subject entity.
func (lpuo *LessonPlanUpdateOne) ClearSubjects() *LessonPlanUpdateOne {
	lpuo.mutation.ClearSubjects()
	return lpuo
}

// RemoveSubjectIDs removes the "subjects" edge to Subject entities by IDs.
func (lpuo *LessonPlanUpdateOne) RemoveSubjectIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.RemoveSubjectIDs(ids...)
	return lpuo
}

// RemoveSubjects removes "subjects" edges to Subject entities.
func (lpuo *LessonPlanUpdateOne) RemoveSubjects(s ...*Subject) *LessonPlanUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return lpuo.RemoveSubjectIDs(ids...)
}

// ClearEducationCategories clears all "education_categories" edges to the EducationCategory entity.
func (lpuo *LessonPlanUpdateOne) ClearEducationCategories() *LessonPlanUpdateOne {
	lpuo.mutation.ClearEducationCategories()
	return lpuo
}

// RemoveEducationCategoryIDs removes the "education_categories" edge to EducationCategory entities by IDs.
func (lpuo *LessonPlanUpdateOne) RemoveEducationCategoryIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.RemoveEducationCategoryIDs(ids...)
	return lpuo
}

// RemoveEducationCategories removes "education_categories" edges to EducationCategory entities.
func (lpuo *LessonPlanUpdateOne) RemoveEducationCategories(e ...*EducationCategory) *LessonPlanUpdateOne {
	ids := make([]int, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return lpuo.RemoveEducationCategoryIDs(ids...)
}

// ClearUploadFiles clears all "upload_files" edges to the UploadFile entity.
func (lpuo *LessonPlanUpdateOne) ClearUploadFiles() *LessonPlanUpdateOne {
	lpuo.mutation.ClearUploadFiles()
	return lpuo
}

// RemoveUploadFileIDs removes the "upload_files" edge to UploadFile entities by IDs.
func (lpuo *LessonPlanUpdateOne) RemoveUploadFileIDs(ids ...int) *LessonPlanUpdateOne {
	lpuo.mutation.RemoveUploadFileIDs(ids...)
	return lpuo
}

// RemoveUploadFiles removes "upload_files" edges to UploadFile entities.
func (lpuo *LessonPlanUpdateOne) RemoveUploadFiles(u ...*UploadFile) *LessonPlanUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return lpuo.RemoveUploadFileIDs(ids...)
}

// Where appends a list predicates to the LessonPlanUpdate builder.
func (lpuo *LessonPlanUpdateOne) Where(ps ...predicate.LessonPlan) *LessonPlanUpdateOne {
	lpuo.mutation.Where(ps...)
	return lpuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (lpuo *LessonPlanUpdateOne) Select(field string, fields ...string) *LessonPlanUpdateOne {
	lpuo.fields = append([]string{field}, fields...)
	return lpuo
}

// Save executes the query and returns the updated LessonPlan entity.
func (lpuo *LessonPlanUpdateOne) Save(ctx context.Context) (*LessonPlan, error) {
	lpuo.defaults()
	return withHooks(ctx, lpuo.sqlSave, lpuo.mutation, lpuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (lpuo *LessonPlanUpdateOne) SaveX(ctx context.Context) *LessonPlan {
	node, err := lpuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (lpuo *LessonPlanUpdateOne) Exec(ctx context.Context) error {
	_, err := lpuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (lpuo *LessonPlanUpdateOne) ExecX(ctx context.Context) {
	if err := lpuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (lpuo *LessonPlanUpdateOne) defaults() {
	if _, ok := lpuo.mutation.UpdatedAt(); !ok {
		v := lessonplan.UpdateDefaultUpdatedAt()
		lpuo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (lpuo *LessonPlanUpdateOne) check() error {
	if v, ok := lpuo.mutation.CompanyID(); ok {
		if err := lessonplan.CompanyIDValidator(v); err != nil {
			return &ValidationError{Name: "company_id", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.company_id": %w`, err)}
		}
	}
	if v, ok := lpuo.mutation.Title(); ok {
		if err := lessonplan.TitleValidator(v); err != nil {
			return &ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.title": %w`, err)}
		}
	}
	if v, ok := lpuo.mutation.Description(); ok {
		if err := lessonplan.DescriptionValidator(v); err != nil {
			return &ValidationError{Name: "description", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.description": %w`, err)}
		}
	}
	if v, ok := lpuo.mutation.Location(); ok {
		if err := lessonplan.LocationValidator(v); err != nil {
			return &ValidationError{Name: "location", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.location": %w`, err)}
		}
	}
	if v, ok := lpuo.mutation.LessonType(); ok {
		if err := lessonplan.LessonTypeValidator(v); err != nil {
			return &ValidationError{Name: "lesson_type", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.lesson_type": %w`, err)}
		}
	}
	if v, ok := lpuo.mutation.AnnualMaxExecutions(); ok {
		if err := lessonplan.AnnualMaxExecutionsValidator(v); err != nil {
			return &ValidationError{Name: "annual_max_executions", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.annual_max_executions": %w`, err)}
		}
	}
	if v, ok := lpuo.mutation.StartMonth(); ok {
		if err := lessonplan.StartMonthValidator(v); err != nil {
			return &ValidationError{Name: "start_month", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.start_month": %w`, err)}
		}
	}
	if v, ok := lpuo.mutation.StartDay(); ok {
		if err := lessonplan.StartDayValidator(v); err != nil {
			return &ValidationError{Name: "start_day", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.start_day": %w`, err)}
		}
	}
	if v, ok := lpuo.mutation.EndMonth(); ok {
		if err := lessonplan.EndMonthValidator(v); err != nil {
			return &ValidationError{Name: "end_month", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.end_month": %w`, err)}
		}
	}
	if v, ok := lpuo.mutation.EndDay(); ok {
		if err := lessonplan.EndDayValidator(v); err != nil {
			return &ValidationError{Name: "end_day", err: fmt.Errorf(`ent: validator failed for field "LessonPlan.end_day": %w`, err)}
		}
	}
	if lpuo.mutation.CompanyCleared() && len(lpuo.mutation.CompanyIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "LessonPlan.company"`)
	}
	return nil
}

func (lpuo *LessonPlanUpdateOne) sqlSave(ctx context.Context) (_node *LessonPlan, err error) {
	if err := lpuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(lessonplan.Table, lessonplan.Columns, sqlgraph.NewFieldSpec(lessonplan.FieldID, field.TypeInt))
	id, ok := lpuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "LessonPlan.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := lpuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, lessonplan.FieldID)
		for _, f := range fields {
			if !lessonplan.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != lessonplan.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := lpuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := lpuo.mutation.UpdatedAt(); ok {
		_spec.SetField(lessonplan.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := lpuo.mutation.Title(); ok {
		_spec.SetField(lessonplan.FieldTitle, field.TypeString, value)
	}
	if value, ok := lpuo.mutation.Description(); ok {
		_spec.SetField(lessonplan.FieldDescription, field.TypeString, value)
	}
	if lpuo.mutation.DescriptionCleared() {
		_spec.ClearField(lessonplan.FieldDescription, field.TypeString)
	}
	if value, ok := lpuo.mutation.Location(); ok {
		_spec.SetField(lessonplan.FieldLocation, field.TypeString, value)
	}
	if lpuo.mutation.LocationCleared() {
		_spec.ClearField(lessonplan.FieldLocation, field.TypeString)
	}
	if value, ok := lpuo.mutation.LessonType(); ok {
		_spec.SetField(lessonplan.FieldLessonType, field.TypeEnum, value)
	}
	if value, ok := lpuo.mutation.AnnualMaxExecutions(); ok {
		_spec.SetField(lessonplan.FieldAnnualMaxExecutions, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.AddedAnnualMaxExecutions(); ok {
		_spec.AddField(lessonplan.FieldAnnualMaxExecutions, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.StartMonth(); ok {
		_spec.SetField(lessonplan.FieldStartMonth, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.AddedStartMonth(); ok {
		_spec.AddField(lessonplan.FieldStartMonth, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.StartDay(); ok {
		_spec.SetField(lessonplan.FieldStartDay, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.AddedStartDay(); ok {
		_spec.AddField(lessonplan.FieldStartDay, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.EndMonth(); ok {
		_spec.SetField(lessonplan.FieldEndMonth, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.AddedEndMonth(); ok {
		_spec.AddField(lessonplan.FieldEndMonth, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.EndDay(); ok {
		_spec.SetField(lessonplan.FieldEndDay, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.AddedEndDay(); ok {
		_spec.AddField(lessonplan.FieldEndDay, field.TypeInt, value)
	}
	if value, ok := lpuo.mutation.StartTime(); ok {
		_spec.SetField(lessonplan.FieldStartTime, field.TypeTime, value)
	}
	if value, ok := lpuo.mutation.EndTime(); ok {
		_spec.SetField(lessonplan.FieldEndTime, field.TypeTime, value)
	}
	if lpuo.mutation.CompanyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   lessonplan.CompanyTable,
			Columns: []string{lessonplan.CompanyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(company.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.CompanyIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   lessonplan.CompanyTable,
			Columns: []string{lessonplan.CompanyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(company.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpuo.mutation.SchedulesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.SchedulesTable,
			Columns: []string{lessonplan.SchedulesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonschedule.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.RemovedSchedulesIDs(); len(nodes) > 0 && !lpuo.mutation.SchedulesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.SchedulesTable,
			Columns: []string{lessonplan.SchedulesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonschedule.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.SchedulesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.SchedulesTable,
			Columns: []string{lessonplan.SchedulesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonschedule.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpuo.mutation.GradesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.GradesTable,
			Columns: lessonplan.GradesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.RemovedGradesIDs(); len(nodes) > 0 && !lpuo.mutation.GradesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.GradesTable,
			Columns: lessonplan.GradesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.GradesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.GradesTable,
			Columns: lessonplan.GradesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpuo.mutation.SubjectsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.SubjectsTable,
			Columns: lessonplan.SubjectsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.RemovedSubjectsIDs(); len(nodes) > 0 && !lpuo.mutation.SubjectsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.SubjectsTable,
			Columns: lessonplan.SubjectsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.SubjectsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.SubjectsTable,
			Columns: lessonplan.SubjectsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpuo.mutation.EducationCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.EducationCategoriesTable,
			Columns: lessonplan.EducationCategoriesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.RemovedEducationCategoriesIDs(); len(nodes) > 0 && !lpuo.mutation.EducationCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.EducationCategoriesTable,
			Columns: lessonplan.EducationCategoriesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.EducationCategoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   lessonplan.EducationCategoriesTable,
			Columns: lessonplan.EducationCategoriesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lpuo.mutation.UploadFilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.UploadFilesTable,
			Columns: []string{lessonplan.UploadFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(uploadfile.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.RemovedUploadFilesIDs(); len(nodes) > 0 && !lpuo.mutation.UploadFilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.UploadFilesTable,
			Columns: []string{lessonplan.UploadFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(uploadfile.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lpuo.mutation.UploadFilesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonplan.UploadFilesTable,
			Columns: []string{lessonplan.UploadFilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(uploadfile.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &LessonPlan{config: lpuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, lpuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{lessonplan.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	lpuo.mutation.done = true
	return _node, nil
}
