// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/educationcategory"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/grade"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonplan"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonreservation"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/lessonschedule"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/predicate"
	"github.com/takuyakawta/spot-teacher-sample/db/ent/subject"
)

// LessonScheduleUpdate is the builder for updating LessonSchedule entities.
type LessonScheduleUpdate struct {
	config
	hooks    []Hook
	mutation *LessonScheduleMutation
}

// Where appends a list predicates to the LessonScheduleUpdate builder.
func (lsu *LessonScheduleUpdate) Where(ps ...predicate.LessonSchedule) *LessonScheduleUpdate {
	lsu.mutation.Where(ps...)
	return lsu
}

// SetUpdatedAt sets the "updated_at" field.
func (lsu *LessonScheduleUpdate) SetUpdatedAt(t time.Time) *LessonScheduleUpdate {
	lsu.mutation.SetUpdatedAt(t)
	return lsu
}

// SetLessonPlanID sets the "lesson_plan_id" field.
func (lsu *LessonScheduleUpdate) SetLessonPlanID(i int64) *LessonScheduleUpdate {
	lsu.mutation.SetLessonPlanID(i)
	return lsu
}

// SetNillableLessonPlanID sets the "lesson_plan_id" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableLessonPlanID(i *int64) *LessonScheduleUpdate {
	if i != nil {
		lsu.SetLessonPlanID(*i)
	}
	return lsu
}

// SetTitle sets the "title" field.
func (lsu *LessonScheduleUpdate) SetTitle(s string) *LessonScheduleUpdate {
	lsu.mutation.SetTitle(s)
	return lsu
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableTitle(s *string) *LessonScheduleUpdate {
	if s != nil {
		lsu.SetTitle(*s)
	}
	return lsu
}

// SetDescription sets the "description" field.
func (lsu *LessonScheduleUpdate) SetDescription(s string) *LessonScheduleUpdate {
	lsu.mutation.SetDescription(s)
	return lsu
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableDescription(s *string) *LessonScheduleUpdate {
	if s != nil {
		lsu.SetDescription(*s)
	}
	return lsu
}

// ClearDescription clears the value of the "description" field.
func (lsu *LessonScheduleUpdate) ClearDescription() *LessonScheduleUpdate {
	lsu.mutation.ClearDescription()
	return lsu
}

// SetLocation sets the "location" field.
func (lsu *LessonScheduleUpdate) SetLocation(s string) *LessonScheduleUpdate {
	lsu.mutation.SetLocation(s)
	return lsu
}

// SetNillableLocation sets the "location" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableLocation(s *string) *LessonScheduleUpdate {
	if s != nil {
		lsu.SetLocation(*s)
	}
	return lsu
}

// ClearLocation clears the value of the "location" field.
func (lsu *LessonScheduleUpdate) ClearLocation() *LessonScheduleUpdate {
	lsu.mutation.ClearLocation()
	return lsu
}

// SetLessonType sets the "lesson_type" field.
func (lsu *LessonScheduleUpdate) SetLessonType(lt lessonschedule.LessonType) *LessonScheduleUpdate {
	lsu.mutation.SetLessonType(lt)
	return lsu
}

// SetNillableLessonType sets the "lesson_type" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableLessonType(lt *lessonschedule.LessonType) *LessonScheduleUpdate {
	if lt != nil {
		lsu.SetLessonType(*lt)
	}
	return lsu
}

// SetAnnualMaxExecutions sets the "annual_max_executions" field.
func (lsu *LessonScheduleUpdate) SetAnnualMaxExecutions(i int) *LessonScheduleUpdate {
	lsu.mutation.ResetAnnualMaxExecutions()
	lsu.mutation.SetAnnualMaxExecutions(i)
	return lsu
}

// SetNillableAnnualMaxExecutions sets the "annual_max_executions" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableAnnualMaxExecutions(i *int) *LessonScheduleUpdate {
	if i != nil {
		lsu.SetAnnualMaxExecutions(*i)
	}
	return lsu
}

// AddAnnualMaxExecutions adds i to the "annual_max_executions" field.
func (lsu *LessonScheduleUpdate) AddAnnualMaxExecutions(i int) *LessonScheduleUpdate {
	lsu.mutation.AddAnnualMaxExecutions(i)
	return lsu
}

// SetStartDate sets the "start_date" field.
func (lsu *LessonScheduleUpdate) SetStartDate(t time.Time) *LessonScheduleUpdate {
	lsu.mutation.SetStartDate(t)
	return lsu
}

// SetNillableStartDate sets the "start_date" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableStartDate(t *time.Time) *LessonScheduleUpdate {
	if t != nil {
		lsu.SetStartDate(*t)
	}
	return lsu
}

// SetEndDate sets the "end_date" field.
func (lsu *LessonScheduleUpdate) SetEndDate(t time.Time) *LessonScheduleUpdate {
	lsu.mutation.SetEndDate(t)
	return lsu
}

// SetNillableEndDate sets the "end_date" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableEndDate(t *time.Time) *LessonScheduleUpdate {
	if t != nil {
		lsu.SetEndDate(*t)
	}
	return lsu
}

// SetStartTime sets the "start_time" field.
func (lsu *LessonScheduleUpdate) SetStartTime(t time.Time) *LessonScheduleUpdate {
	lsu.mutation.SetStartTime(t)
	return lsu
}

// SetNillableStartTime sets the "start_time" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableStartTime(t *time.Time) *LessonScheduleUpdate {
	if t != nil {
		lsu.SetStartTime(*t)
	}
	return lsu
}

// SetEndTime sets the "end_time" field.
func (lsu *LessonScheduleUpdate) SetEndTime(t time.Time) *LessonScheduleUpdate {
	lsu.mutation.SetEndTime(t)
	return lsu
}

// SetNillableEndTime sets the "end_time" field if the given value is not nil.
func (lsu *LessonScheduleUpdate) SetNillableEndTime(t *time.Time) *LessonScheduleUpdate {
	if t != nil {
		lsu.SetEndTime(*t)
	}
	return lsu
}

// SetPlanID sets the "plan" edge to the LessonPlan entity by ID.
func (lsu *LessonScheduleUpdate) SetPlanID(id int64) *LessonScheduleUpdate {
	lsu.mutation.SetPlanID(id)
	return lsu
}

// SetPlan sets the "plan" edge to the LessonPlan entity.
func (lsu *LessonScheduleUpdate) SetPlan(l *LessonPlan) *LessonScheduleUpdate {
	return lsu.SetPlanID(l.ID)
}

// AddGradeIDs adds the "grades" edge to the Grade entity by IDs.
func (lsu *LessonScheduleUpdate) AddGradeIDs(ids ...int64) *LessonScheduleUpdate {
	lsu.mutation.AddGradeIDs(ids...)
	return lsu
}

// AddGrades adds the "grades" edges to the Grade entity.
func (lsu *LessonScheduleUpdate) AddGrades(g ...*Grade) *LessonScheduleUpdate {
	ids := make([]int64, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return lsu.AddGradeIDs(ids...)
}

// AddSubjectIDs adds the "subjects" edge to the Subject entity by IDs.
func (lsu *LessonScheduleUpdate) AddSubjectIDs(ids ...int64) *LessonScheduleUpdate {
	lsu.mutation.AddSubjectIDs(ids...)
	return lsu
}

// AddSubjects adds the "subjects" edges to the Subject entity.
func (lsu *LessonScheduleUpdate) AddSubjects(s ...*Subject) *LessonScheduleUpdate {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return lsu.AddSubjectIDs(ids...)
}

// AddEducationCategoryIDs adds the "education_categories" edge to the EducationCategory entity by IDs.
func (lsu *LessonScheduleUpdate) AddEducationCategoryIDs(ids ...int64) *LessonScheduleUpdate {
	lsu.mutation.AddEducationCategoryIDs(ids...)
	return lsu
}

// AddEducationCategories adds the "education_categories" edges to the EducationCategory entity.
func (lsu *LessonScheduleUpdate) AddEducationCategories(e ...*EducationCategory) *LessonScheduleUpdate {
	ids := make([]int64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return lsu.AddEducationCategoryIDs(ids...)
}

// AddLessonReservationIDs adds the "lesson_reservations" edge to the LessonReservation entity by IDs.
func (lsu *LessonScheduleUpdate) AddLessonReservationIDs(ids ...int64) *LessonScheduleUpdate {
	lsu.mutation.AddLessonReservationIDs(ids...)
	return lsu
}

// AddLessonReservations adds the "lesson_reservations" edges to the LessonReservation entity.
func (lsu *LessonScheduleUpdate) AddLessonReservations(l ...*LessonReservation) *LessonScheduleUpdate {
	ids := make([]int64, len(l))
	for i := range l {
		ids[i] = l[i].ID
	}
	return lsu.AddLessonReservationIDs(ids...)
}

// Mutation returns the LessonScheduleMutation object of the builder.
func (lsu *LessonScheduleUpdate) Mutation() *LessonScheduleMutation {
	return lsu.mutation
}

// ClearPlan clears the "plan" edge to the LessonPlan entity.
func (lsu *LessonScheduleUpdate) ClearPlan() *LessonScheduleUpdate {
	lsu.mutation.ClearPlan()
	return lsu
}

// ClearGrades clears all "grades" edges to the Grade entity.
func (lsu *LessonScheduleUpdate) ClearGrades() *LessonScheduleUpdate {
	lsu.mutation.ClearGrades()
	return lsu
}

// RemoveGradeIDs removes the "grades" edge to Grade entities by IDs.
func (lsu *LessonScheduleUpdate) RemoveGradeIDs(ids ...int64) *LessonScheduleUpdate {
	lsu.mutation.RemoveGradeIDs(ids...)
	return lsu
}

// RemoveGrades removes "grades" edges to Grade entities.
func (lsu *LessonScheduleUpdate) RemoveGrades(g ...*Grade) *LessonScheduleUpdate {
	ids := make([]int64, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return lsu.RemoveGradeIDs(ids...)
}

// ClearSubjects clears all "subjects" edges to the Subject entity.
func (lsu *LessonScheduleUpdate) ClearSubjects() *LessonScheduleUpdate {
	lsu.mutation.ClearSubjects()
	return lsu
}

// RemoveSubjectIDs removes the "subjects" edge to Subject entities by IDs.
func (lsu *LessonScheduleUpdate) RemoveSubjectIDs(ids ...int64) *LessonScheduleUpdate {
	lsu.mutation.RemoveSubjectIDs(ids...)
	return lsu
}

// RemoveSubjects removes "subjects" edges to Subject entities.
func (lsu *LessonScheduleUpdate) RemoveSubjects(s ...*Subject) *LessonScheduleUpdate {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return lsu.RemoveSubjectIDs(ids...)
}

// ClearEducationCategories clears all "education_categories" edges to the EducationCategory entity.
func (lsu *LessonScheduleUpdate) ClearEducationCategories() *LessonScheduleUpdate {
	lsu.mutation.ClearEducationCategories()
	return lsu
}

// RemoveEducationCategoryIDs removes the "education_categories" edge to EducationCategory entities by IDs.
func (lsu *LessonScheduleUpdate) RemoveEducationCategoryIDs(ids ...int64) *LessonScheduleUpdate {
	lsu.mutation.RemoveEducationCategoryIDs(ids...)
	return lsu
}

// RemoveEducationCategories removes "education_categories" edges to EducationCategory entities.
func (lsu *LessonScheduleUpdate) RemoveEducationCategories(e ...*EducationCategory) *LessonScheduleUpdate {
	ids := make([]int64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return lsu.RemoveEducationCategoryIDs(ids...)
}

// ClearLessonReservations clears all "lesson_reservations" edges to the LessonReservation entity.
func (lsu *LessonScheduleUpdate) ClearLessonReservations() *LessonScheduleUpdate {
	lsu.mutation.ClearLessonReservations()
	return lsu
}

// RemoveLessonReservationIDs removes the "lesson_reservations" edge to LessonReservation entities by IDs.
func (lsu *LessonScheduleUpdate) RemoveLessonReservationIDs(ids ...int64) *LessonScheduleUpdate {
	lsu.mutation.RemoveLessonReservationIDs(ids...)
	return lsu
}

// RemoveLessonReservations removes "lesson_reservations" edges to LessonReservation entities.
func (lsu *LessonScheduleUpdate) RemoveLessonReservations(l ...*LessonReservation) *LessonScheduleUpdate {
	ids := make([]int64, len(l))
	for i := range l {
		ids[i] = l[i].ID
	}
	return lsu.RemoveLessonReservationIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (lsu *LessonScheduleUpdate) Save(ctx context.Context) (int, error) {
	lsu.defaults()
	return withHooks(ctx, lsu.sqlSave, lsu.mutation, lsu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (lsu *LessonScheduleUpdate) SaveX(ctx context.Context) int {
	affected, err := lsu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (lsu *LessonScheduleUpdate) Exec(ctx context.Context) error {
	_, err := lsu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (lsu *LessonScheduleUpdate) ExecX(ctx context.Context) {
	if err := lsu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (lsu *LessonScheduleUpdate) defaults() {
	if _, ok := lsu.mutation.UpdatedAt(); !ok {
		v := lessonschedule.UpdateDefaultUpdatedAt()
		lsu.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (lsu *LessonScheduleUpdate) check() error {
	if v, ok := lsu.mutation.LessonPlanID(); ok {
		if err := lessonschedule.LessonPlanIDValidator(v); err != nil {
			return &ValidationError{Name: "lesson_plan_id", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.lesson_plan_id": %w`, err)}
		}
	}
	if v, ok := lsu.mutation.Title(); ok {
		if err := lessonschedule.TitleValidator(v); err != nil {
			return &ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.title": %w`, err)}
		}
	}
	if v, ok := lsu.mutation.Description(); ok {
		if err := lessonschedule.DescriptionValidator(v); err != nil {
			return &ValidationError{Name: "description", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.description": %w`, err)}
		}
	}
	if v, ok := lsu.mutation.Location(); ok {
		if err := lessonschedule.LocationValidator(v); err != nil {
			return &ValidationError{Name: "location", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.location": %w`, err)}
		}
	}
	if v, ok := lsu.mutation.LessonType(); ok {
		if err := lessonschedule.LessonTypeValidator(v); err != nil {
			return &ValidationError{Name: "lesson_type", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.lesson_type": %w`, err)}
		}
	}
	if v, ok := lsu.mutation.AnnualMaxExecutions(); ok {
		if err := lessonschedule.AnnualMaxExecutionsValidator(v); err != nil {
			return &ValidationError{Name: "annual_max_executions", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.annual_max_executions": %w`, err)}
		}
	}
	if lsu.mutation.PlanCleared() && len(lsu.mutation.PlanIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "LessonSchedule.plan"`)
	}
	return nil
}

func (lsu *LessonScheduleUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := lsu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(lessonschedule.Table, lessonschedule.Columns, sqlgraph.NewFieldSpec(lessonschedule.FieldID, field.TypeInt64))
	if ps := lsu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := lsu.mutation.UpdatedAt(); ok {
		_spec.SetField(lessonschedule.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := lsu.mutation.Title(); ok {
		_spec.SetField(lessonschedule.FieldTitle, field.TypeString, value)
	}
	if value, ok := lsu.mutation.Description(); ok {
		_spec.SetField(lessonschedule.FieldDescription, field.TypeString, value)
	}
	if lsu.mutation.DescriptionCleared() {
		_spec.ClearField(lessonschedule.FieldDescription, field.TypeString)
	}
	if value, ok := lsu.mutation.Location(); ok {
		_spec.SetField(lessonschedule.FieldLocation, field.TypeString, value)
	}
	if lsu.mutation.LocationCleared() {
		_spec.ClearField(lessonschedule.FieldLocation, field.TypeString)
	}
	if value, ok := lsu.mutation.LessonType(); ok {
		_spec.SetField(lessonschedule.FieldLessonType, field.TypeEnum, value)
	}
	if value, ok := lsu.mutation.AnnualMaxExecutions(); ok {
		_spec.SetField(lessonschedule.FieldAnnualMaxExecutions, field.TypeInt, value)
	}
	if value, ok := lsu.mutation.AddedAnnualMaxExecutions(); ok {
		_spec.AddField(lessonschedule.FieldAnnualMaxExecutions, field.TypeInt, value)
	}
	if value, ok := lsu.mutation.StartDate(); ok {
		_spec.SetField(lessonschedule.FieldStartDate, field.TypeTime, value)
	}
	if value, ok := lsu.mutation.EndDate(); ok {
		_spec.SetField(lessonschedule.FieldEndDate, field.TypeTime, value)
	}
	if value, ok := lsu.mutation.StartTime(); ok {
		_spec.SetField(lessonschedule.FieldStartTime, field.TypeTime, value)
	}
	if value, ok := lsu.mutation.EndTime(); ok {
		_spec.SetField(lessonschedule.FieldEndTime, field.TypeTime, value)
	}
	if lsu.mutation.PlanCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   lessonschedule.PlanTable,
			Columns: []string{lessonschedule.PlanColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonplan.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsu.mutation.PlanIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   lessonschedule.PlanTable,
			Columns: []string{lessonschedule.PlanColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonplan.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lsu.mutation.GradesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.GradesTable,
			Columns: []string{lessonschedule.GradesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsu.mutation.RemovedGradesIDs(); len(nodes) > 0 && !lsu.mutation.GradesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.GradesTable,
			Columns: []string{lessonschedule.GradesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsu.mutation.GradesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.GradesTable,
			Columns: []string{lessonschedule.GradesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lsu.mutation.SubjectsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.SubjectsTable,
			Columns: []string{lessonschedule.SubjectsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsu.mutation.RemovedSubjectsIDs(); len(nodes) > 0 && !lsu.mutation.SubjectsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.SubjectsTable,
			Columns: []string{lessonschedule.SubjectsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsu.mutation.SubjectsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.SubjectsTable,
			Columns: []string{lessonschedule.SubjectsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lsu.mutation.EducationCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.EducationCategoriesTable,
			Columns: []string{lessonschedule.EducationCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsu.mutation.RemovedEducationCategoriesIDs(); len(nodes) > 0 && !lsu.mutation.EducationCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.EducationCategoriesTable,
			Columns: []string{lessonschedule.EducationCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsu.mutation.EducationCategoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.EducationCategoriesTable,
			Columns: []string{lessonschedule.EducationCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lsu.mutation.LessonReservationsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.LessonReservationsTable,
			Columns: []string{lessonschedule.LessonReservationsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonreservation.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsu.mutation.RemovedLessonReservationsIDs(); len(nodes) > 0 && !lsu.mutation.LessonReservationsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.LessonReservationsTable,
			Columns: []string{lessonschedule.LessonReservationsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonreservation.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsu.mutation.LessonReservationsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.LessonReservationsTable,
			Columns: []string{lessonschedule.LessonReservationsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonreservation.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, lsu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{lessonschedule.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	lsu.mutation.done = true
	return n, nil
}

// LessonScheduleUpdateOne is the builder for updating a single LessonSchedule entity.
type LessonScheduleUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *LessonScheduleMutation
}

// SetUpdatedAt sets the "updated_at" field.
func (lsuo *LessonScheduleUpdateOne) SetUpdatedAt(t time.Time) *LessonScheduleUpdateOne {
	lsuo.mutation.SetUpdatedAt(t)
	return lsuo
}

// SetLessonPlanID sets the "lesson_plan_id" field.
func (lsuo *LessonScheduleUpdateOne) SetLessonPlanID(i int64) *LessonScheduleUpdateOne {
	lsuo.mutation.SetLessonPlanID(i)
	return lsuo
}

// SetNillableLessonPlanID sets the "lesson_plan_id" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableLessonPlanID(i *int64) *LessonScheduleUpdateOne {
	if i != nil {
		lsuo.SetLessonPlanID(*i)
	}
	return lsuo
}

// SetTitle sets the "title" field.
func (lsuo *LessonScheduleUpdateOne) SetTitle(s string) *LessonScheduleUpdateOne {
	lsuo.mutation.SetTitle(s)
	return lsuo
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableTitle(s *string) *LessonScheduleUpdateOne {
	if s != nil {
		lsuo.SetTitle(*s)
	}
	return lsuo
}

// SetDescription sets the "description" field.
func (lsuo *LessonScheduleUpdateOne) SetDescription(s string) *LessonScheduleUpdateOne {
	lsuo.mutation.SetDescription(s)
	return lsuo
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableDescription(s *string) *LessonScheduleUpdateOne {
	if s != nil {
		lsuo.SetDescription(*s)
	}
	return lsuo
}

// ClearDescription clears the value of the "description" field.
func (lsuo *LessonScheduleUpdateOne) ClearDescription() *LessonScheduleUpdateOne {
	lsuo.mutation.ClearDescription()
	return lsuo
}

// SetLocation sets the "location" field.
func (lsuo *LessonScheduleUpdateOne) SetLocation(s string) *LessonScheduleUpdateOne {
	lsuo.mutation.SetLocation(s)
	return lsuo
}

// SetNillableLocation sets the "location" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableLocation(s *string) *LessonScheduleUpdateOne {
	if s != nil {
		lsuo.SetLocation(*s)
	}
	return lsuo
}

// ClearLocation clears the value of the "location" field.
func (lsuo *LessonScheduleUpdateOne) ClearLocation() *LessonScheduleUpdateOne {
	lsuo.mutation.ClearLocation()
	return lsuo
}

// SetLessonType sets the "lesson_type" field.
func (lsuo *LessonScheduleUpdateOne) SetLessonType(lt lessonschedule.LessonType) *LessonScheduleUpdateOne {
	lsuo.mutation.SetLessonType(lt)
	return lsuo
}

// SetNillableLessonType sets the "lesson_type" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableLessonType(lt *lessonschedule.LessonType) *LessonScheduleUpdateOne {
	if lt != nil {
		lsuo.SetLessonType(*lt)
	}
	return lsuo
}

// SetAnnualMaxExecutions sets the "annual_max_executions" field.
func (lsuo *LessonScheduleUpdateOne) SetAnnualMaxExecutions(i int) *LessonScheduleUpdateOne {
	lsuo.mutation.ResetAnnualMaxExecutions()
	lsuo.mutation.SetAnnualMaxExecutions(i)
	return lsuo
}

// SetNillableAnnualMaxExecutions sets the "annual_max_executions" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableAnnualMaxExecutions(i *int) *LessonScheduleUpdateOne {
	if i != nil {
		lsuo.SetAnnualMaxExecutions(*i)
	}
	return lsuo
}

// AddAnnualMaxExecutions adds i to the "annual_max_executions" field.
func (lsuo *LessonScheduleUpdateOne) AddAnnualMaxExecutions(i int) *LessonScheduleUpdateOne {
	lsuo.mutation.AddAnnualMaxExecutions(i)
	return lsuo
}

// SetStartDate sets the "start_date" field.
func (lsuo *LessonScheduleUpdateOne) SetStartDate(t time.Time) *LessonScheduleUpdateOne {
	lsuo.mutation.SetStartDate(t)
	return lsuo
}

// SetNillableStartDate sets the "start_date" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableStartDate(t *time.Time) *LessonScheduleUpdateOne {
	if t != nil {
		lsuo.SetStartDate(*t)
	}
	return lsuo
}

// SetEndDate sets the "end_date" field.
func (lsuo *LessonScheduleUpdateOne) SetEndDate(t time.Time) *LessonScheduleUpdateOne {
	lsuo.mutation.SetEndDate(t)
	return lsuo
}

// SetNillableEndDate sets the "end_date" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableEndDate(t *time.Time) *LessonScheduleUpdateOne {
	if t != nil {
		lsuo.SetEndDate(*t)
	}
	return lsuo
}

// SetStartTime sets the "start_time" field.
func (lsuo *LessonScheduleUpdateOne) SetStartTime(t time.Time) *LessonScheduleUpdateOne {
	lsuo.mutation.SetStartTime(t)
	return lsuo
}

// SetNillableStartTime sets the "start_time" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableStartTime(t *time.Time) *LessonScheduleUpdateOne {
	if t != nil {
		lsuo.SetStartTime(*t)
	}
	return lsuo
}

// SetEndTime sets the "end_time" field.
func (lsuo *LessonScheduleUpdateOne) SetEndTime(t time.Time) *LessonScheduleUpdateOne {
	lsuo.mutation.SetEndTime(t)
	return lsuo
}

// SetNillableEndTime sets the "end_time" field if the given value is not nil.
func (lsuo *LessonScheduleUpdateOne) SetNillableEndTime(t *time.Time) *LessonScheduleUpdateOne {
	if t != nil {
		lsuo.SetEndTime(*t)
	}
	return lsuo
}

// SetPlanID sets the "plan" edge to the LessonPlan entity by ID.
func (lsuo *LessonScheduleUpdateOne) SetPlanID(id int64) *LessonScheduleUpdateOne {
	lsuo.mutation.SetPlanID(id)
	return lsuo
}

// SetPlan sets the "plan" edge to the LessonPlan entity.
func (lsuo *LessonScheduleUpdateOne) SetPlan(l *LessonPlan) *LessonScheduleUpdateOne {
	return lsuo.SetPlanID(l.ID)
}

// AddGradeIDs adds the "grades" edge to the Grade entity by IDs.
func (lsuo *LessonScheduleUpdateOne) AddGradeIDs(ids ...int64) *LessonScheduleUpdateOne {
	lsuo.mutation.AddGradeIDs(ids...)
	return lsuo
}

// AddGrades adds the "grades" edges to the Grade entity.
func (lsuo *LessonScheduleUpdateOne) AddGrades(g ...*Grade) *LessonScheduleUpdateOne {
	ids := make([]int64, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return lsuo.AddGradeIDs(ids...)
}

// AddSubjectIDs adds the "subjects" edge to the Subject entity by IDs.
func (lsuo *LessonScheduleUpdateOne) AddSubjectIDs(ids ...int64) *LessonScheduleUpdateOne {
	lsuo.mutation.AddSubjectIDs(ids...)
	return lsuo
}

// AddSubjects adds the "subjects" edges to the Subject entity.
func (lsuo *LessonScheduleUpdateOne) AddSubjects(s ...*Subject) *LessonScheduleUpdateOne {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return lsuo.AddSubjectIDs(ids...)
}

// AddEducationCategoryIDs adds the "education_categories" edge to the EducationCategory entity by IDs.
func (lsuo *LessonScheduleUpdateOne) AddEducationCategoryIDs(ids ...int64) *LessonScheduleUpdateOne {
	lsuo.mutation.AddEducationCategoryIDs(ids...)
	return lsuo
}

// AddEducationCategories adds the "education_categories" edges to the EducationCategory entity.
func (lsuo *LessonScheduleUpdateOne) AddEducationCategories(e ...*EducationCategory) *LessonScheduleUpdateOne {
	ids := make([]int64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return lsuo.AddEducationCategoryIDs(ids...)
}

// AddLessonReservationIDs adds the "lesson_reservations" edge to the LessonReservation entity by IDs.
func (lsuo *LessonScheduleUpdateOne) AddLessonReservationIDs(ids ...int64) *LessonScheduleUpdateOne {
	lsuo.mutation.AddLessonReservationIDs(ids...)
	return lsuo
}

// AddLessonReservations adds the "lesson_reservations" edges to the LessonReservation entity.
func (lsuo *LessonScheduleUpdateOne) AddLessonReservations(l ...*LessonReservation) *LessonScheduleUpdateOne {
	ids := make([]int64, len(l))
	for i := range l {
		ids[i] = l[i].ID
	}
	return lsuo.AddLessonReservationIDs(ids...)
}

// Mutation returns the LessonScheduleMutation object of the builder.
func (lsuo *LessonScheduleUpdateOne) Mutation() *LessonScheduleMutation {
	return lsuo.mutation
}

// ClearPlan clears the "plan" edge to the LessonPlan entity.
func (lsuo *LessonScheduleUpdateOne) ClearPlan() *LessonScheduleUpdateOne {
	lsuo.mutation.ClearPlan()
	return lsuo
}

// ClearGrades clears all "grades" edges to the Grade entity.
func (lsuo *LessonScheduleUpdateOne) ClearGrades() *LessonScheduleUpdateOne {
	lsuo.mutation.ClearGrades()
	return lsuo
}

// RemoveGradeIDs removes the "grades" edge to Grade entities by IDs.
func (lsuo *LessonScheduleUpdateOne) RemoveGradeIDs(ids ...int64) *LessonScheduleUpdateOne {
	lsuo.mutation.RemoveGradeIDs(ids...)
	return lsuo
}

// RemoveGrades removes "grades" edges to Grade entities.
func (lsuo *LessonScheduleUpdateOne) RemoveGrades(g ...*Grade) *LessonScheduleUpdateOne {
	ids := make([]int64, len(g))
	for i := range g {
		ids[i] = g[i].ID
	}
	return lsuo.RemoveGradeIDs(ids...)
}

// ClearSubjects clears all "subjects" edges to the Subject entity.
func (lsuo *LessonScheduleUpdateOne) ClearSubjects() *LessonScheduleUpdateOne {
	lsuo.mutation.ClearSubjects()
	return lsuo
}

// RemoveSubjectIDs removes the "subjects" edge to Subject entities by IDs.
func (lsuo *LessonScheduleUpdateOne) RemoveSubjectIDs(ids ...int64) *LessonScheduleUpdateOne {
	lsuo.mutation.RemoveSubjectIDs(ids...)
	return lsuo
}

// RemoveSubjects removes "subjects" edges to Subject entities.
func (lsuo *LessonScheduleUpdateOne) RemoveSubjects(s ...*Subject) *LessonScheduleUpdateOne {
	ids := make([]int64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return lsuo.RemoveSubjectIDs(ids...)
}

// ClearEducationCategories clears all "education_categories" edges to the EducationCategory entity.
func (lsuo *LessonScheduleUpdateOne) ClearEducationCategories() *LessonScheduleUpdateOne {
	lsuo.mutation.ClearEducationCategories()
	return lsuo
}

// RemoveEducationCategoryIDs removes the "education_categories" edge to EducationCategory entities by IDs.
func (lsuo *LessonScheduleUpdateOne) RemoveEducationCategoryIDs(ids ...int64) *LessonScheduleUpdateOne {
	lsuo.mutation.RemoveEducationCategoryIDs(ids...)
	return lsuo
}

// RemoveEducationCategories removes "education_categories" edges to EducationCategory entities.
func (lsuo *LessonScheduleUpdateOne) RemoveEducationCategories(e ...*EducationCategory) *LessonScheduleUpdateOne {
	ids := make([]int64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return lsuo.RemoveEducationCategoryIDs(ids...)
}

// ClearLessonReservations clears all "lesson_reservations" edges to the LessonReservation entity.
func (lsuo *LessonScheduleUpdateOne) ClearLessonReservations() *LessonScheduleUpdateOne {
	lsuo.mutation.ClearLessonReservations()
	return lsuo
}

// RemoveLessonReservationIDs removes the "lesson_reservations" edge to LessonReservation entities by IDs.
func (lsuo *LessonScheduleUpdateOne) RemoveLessonReservationIDs(ids ...int64) *LessonScheduleUpdateOne {
	lsuo.mutation.RemoveLessonReservationIDs(ids...)
	return lsuo
}

// RemoveLessonReservations removes "lesson_reservations" edges to LessonReservation entities.
func (lsuo *LessonScheduleUpdateOne) RemoveLessonReservations(l ...*LessonReservation) *LessonScheduleUpdateOne {
	ids := make([]int64, len(l))
	for i := range l {
		ids[i] = l[i].ID
	}
	return lsuo.RemoveLessonReservationIDs(ids...)
}

// Where appends a list predicates to the LessonScheduleUpdate builder.
func (lsuo *LessonScheduleUpdateOne) Where(ps ...predicate.LessonSchedule) *LessonScheduleUpdateOne {
	lsuo.mutation.Where(ps...)
	return lsuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (lsuo *LessonScheduleUpdateOne) Select(field string, fields ...string) *LessonScheduleUpdateOne {
	lsuo.fields = append([]string{field}, fields...)
	return lsuo
}

// Save executes the query and returns the updated LessonSchedule entity.
func (lsuo *LessonScheduleUpdateOne) Save(ctx context.Context) (*LessonSchedule, error) {
	lsuo.defaults()
	return withHooks(ctx, lsuo.sqlSave, lsuo.mutation, lsuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (lsuo *LessonScheduleUpdateOne) SaveX(ctx context.Context) *LessonSchedule {
	node, err := lsuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (lsuo *LessonScheduleUpdateOne) Exec(ctx context.Context) error {
	_, err := lsuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (lsuo *LessonScheduleUpdateOne) ExecX(ctx context.Context) {
	if err := lsuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (lsuo *LessonScheduleUpdateOne) defaults() {
	if _, ok := lsuo.mutation.UpdatedAt(); !ok {
		v := lessonschedule.UpdateDefaultUpdatedAt()
		lsuo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (lsuo *LessonScheduleUpdateOne) check() error {
	if v, ok := lsuo.mutation.LessonPlanID(); ok {
		if err := lessonschedule.LessonPlanIDValidator(v); err != nil {
			return &ValidationError{Name: "lesson_plan_id", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.lesson_plan_id": %w`, err)}
		}
	}
	if v, ok := lsuo.mutation.Title(); ok {
		if err := lessonschedule.TitleValidator(v); err != nil {
			return &ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.title": %w`, err)}
		}
	}
	if v, ok := lsuo.mutation.Description(); ok {
		if err := lessonschedule.DescriptionValidator(v); err != nil {
			return &ValidationError{Name: "description", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.description": %w`, err)}
		}
	}
	if v, ok := lsuo.mutation.Location(); ok {
		if err := lessonschedule.LocationValidator(v); err != nil {
			return &ValidationError{Name: "location", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.location": %w`, err)}
		}
	}
	if v, ok := lsuo.mutation.LessonType(); ok {
		if err := lessonschedule.LessonTypeValidator(v); err != nil {
			return &ValidationError{Name: "lesson_type", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.lesson_type": %w`, err)}
		}
	}
	if v, ok := lsuo.mutation.AnnualMaxExecutions(); ok {
		if err := lessonschedule.AnnualMaxExecutionsValidator(v); err != nil {
			return &ValidationError{Name: "annual_max_executions", err: fmt.Errorf(`ent: validator failed for field "LessonSchedule.annual_max_executions": %w`, err)}
		}
	}
	if lsuo.mutation.PlanCleared() && len(lsuo.mutation.PlanIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "LessonSchedule.plan"`)
	}
	return nil
}

func (lsuo *LessonScheduleUpdateOne) sqlSave(ctx context.Context) (_node *LessonSchedule, err error) {
	if err := lsuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(lessonschedule.Table, lessonschedule.Columns, sqlgraph.NewFieldSpec(lessonschedule.FieldID, field.TypeInt64))
	id, ok := lsuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "LessonSchedule.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := lsuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, lessonschedule.FieldID)
		for _, f := range fields {
			if !lessonschedule.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != lessonschedule.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := lsuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := lsuo.mutation.UpdatedAt(); ok {
		_spec.SetField(lessonschedule.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := lsuo.mutation.Title(); ok {
		_spec.SetField(lessonschedule.FieldTitle, field.TypeString, value)
	}
	if value, ok := lsuo.mutation.Description(); ok {
		_spec.SetField(lessonschedule.FieldDescription, field.TypeString, value)
	}
	if lsuo.mutation.DescriptionCleared() {
		_spec.ClearField(lessonschedule.FieldDescription, field.TypeString)
	}
	if value, ok := lsuo.mutation.Location(); ok {
		_spec.SetField(lessonschedule.FieldLocation, field.TypeString, value)
	}
	if lsuo.mutation.LocationCleared() {
		_spec.ClearField(lessonschedule.FieldLocation, field.TypeString)
	}
	if value, ok := lsuo.mutation.LessonType(); ok {
		_spec.SetField(lessonschedule.FieldLessonType, field.TypeEnum, value)
	}
	if value, ok := lsuo.mutation.AnnualMaxExecutions(); ok {
		_spec.SetField(lessonschedule.FieldAnnualMaxExecutions, field.TypeInt, value)
	}
	if value, ok := lsuo.mutation.AddedAnnualMaxExecutions(); ok {
		_spec.AddField(lessonschedule.FieldAnnualMaxExecutions, field.TypeInt, value)
	}
	if value, ok := lsuo.mutation.StartDate(); ok {
		_spec.SetField(lessonschedule.FieldStartDate, field.TypeTime, value)
	}
	if value, ok := lsuo.mutation.EndDate(); ok {
		_spec.SetField(lessonschedule.FieldEndDate, field.TypeTime, value)
	}
	if value, ok := lsuo.mutation.StartTime(); ok {
		_spec.SetField(lessonschedule.FieldStartTime, field.TypeTime, value)
	}
	if value, ok := lsuo.mutation.EndTime(); ok {
		_spec.SetField(lessonschedule.FieldEndTime, field.TypeTime, value)
	}
	if lsuo.mutation.PlanCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   lessonschedule.PlanTable,
			Columns: []string{lessonschedule.PlanColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonplan.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsuo.mutation.PlanIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   lessonschedule.PlanTable,
			Columns: []string{lessonschedule.PlanColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonplan.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lsuo.mutation.GradesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.GradesTable,
			Columns: []string{lessonschedule.GradesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsuo.mutation.RemovedGradesIDs(); len(nodes) > 0 && !lsuo.mutation.GradesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.GradesTable,
			Columns: []string{lessonschedule.GradesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsuo.mutation.GradesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.GradesTable,
			Columns: []string{lessonschedule.GradesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(grade.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lsuo.mutation.SubjectsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.SubjectsTable,
			Columns: []string{lessonschedule.SubjectsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsuo.mutation.RemovedSubjectsIDs(); len(nodes) > 0 && !lsuo.mutation.SubjectsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.SubjectsTable,
			Columns: []string{lessonschedule.SubjectsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsuo.mutation.SubjectsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.SubjectsTable,
			Columns: []string{lessonschedule.SubjectsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subject.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lsuo.mutation.EducationCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.EducationCategoriesTable,
			Columns: []string{lessonschedule.EducationCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsuo.mutation.RemovedEducationCategoriesIDs(); len(nodes) > 0 && !lsuo.mutation.EducationCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.EducationCategoriesTable,
			Columns: []string{lessonschedule.EducationCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsuo.mutation.EducationCategoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.EducationCategoriesTable,
			Columns: []string{lessonschedule.EducationCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(educationcategory.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if lsuo.mutation.LessonReservationsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.LessonReservationsTable,
			Columns: []string{lessonschedule.LessonReservationsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonreservation.FieldID, field.TypeInt64),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsuo.mutation.RemovedLessonReservationsIDs(); len(nodes) > 0 && !lsuo.mutation.LessonReservationsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.LessonReservationsTable,
			Columns: []string{lessonschedule.LessonReservationsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonreservation.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := lsuo.mutation.LessonReservationsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   lessonschedule.LessonReservationsTable,
			Columns: []string{lessonschedule.LessonReservationsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(lessonreservation.FieldID, field.TypeInt64),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &LessonSchedule{config: lsuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, lsuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{lessonschedule.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	lsuo.mutation.done = true
	return _node, nil
}
